[
{
	"uri": "https://tibcosoftware.github.io/dovetail/introduction/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": " Project Dovetail‚Ñ¢ is an Open Source application for blockchain smart contracts Developing blockchain solutions with today‚Äôs technology is challenging, given the lack of tooling and standardization. Project Dovetail‚Ñ¢ by TIBCO LABS‚Ñ¢ addresses these issues by providing a graphical interface for modeling smart contracts, making them easier to write, visualize, test, and audit, all without deep programming experience. Logic is abstracted from low-level code, and contracts can be deployed into different blockchain stacks with little or no change. On-chain and off-chain computation can become more seamless, time to market is improved, and the risk of technology lock-in is reduced. Project Dovetail makes your smart contracts smarter. \nWhat are Smart Contracts There are many definitions and descriptions of smart contracts, as each blockchain framework tends to implement this capability in its own way (if it does implement this feature at all). However, generally speaking, smart contracts (at least from an enterprise / permissioned perspective) may be thought of as application or business logic (defined in code) that runs within the context of a blockchain network itself. The idea is to automate the processing of blockchain transactions across the network, use the logic to determine if a transaction will get written to the ledger, and to maintain accuracy, compliance, and trust. In essence, smart contracts represent a method for controlling how changes are made to the underlying blockchain, in a non-centralized and (potentially) untrustworthy environment. Supply chain transaction tracking, healthcare revenue cycle management, consumer contract execution, and government interactions are all areas in which smart contracts (business logic) may be applied. Remember, however, that \u0026ldquo;smart contracts\u0026rdquo; are not necessarily \u0026ldquo;smart\u0026rdquo; (depends on the code) nor \u0026ldquo;contracts\u0026rdquo; (as they may not be viewed as legal contracts). Thus, the term can be a bit misleading :)\nProject Dovetail Project Dovetail‚Ñ¢ is a framework that allows for the end to end design, development, testing, and deployment of blockchain smart contracts. Project Dovetail‚Ñ¢ allows you to develop smart contracts based on a series of models, helping to:\n Increase security since the modeling abstraction layer will allow for reusable and tested code derived from the model. Simplify development via an extendable abstraction layer (flow model) Decouple your code from the underlying blockchain technology Reduce the amount of code needed Increase visibility and audit-ability Allow customizable modeling for your industry Expose a better UI for the design of smart contracts  Dovetail Core Dovetail is based on TIBCO FLOGO‚Ñ¢, an event-driven app framework used to develop apps for the cloud \u0026amp; IoT edge. It can also be thought of as a lightweight app kernel used by open source \u0026amp; commercial solutions like Dovetail here. The trigger used is based on the cli to generate or transpile your smart contract logic into blockahin technologies languages : R3 Corda, HyperLedger Fabric\u0026hellip;\nDovetail Core provides the following key benefits:\n‚õì Action chaining enables communication between one or more capabilities in a single, sub 10MB binary! üèó Common contribution model build activities and triggers that can be leveraged by all capabilities üî® Extensible easily extend the capabilities available by building your own action using the common interfaces\nDovetail Core Contribution Model Dovetail‚Ñ¢ Core exposes three principal contribution interfaces that enable developers to build common capabilities and functionality. These contribution interfaces include:\n Trigger Interface a common interface for building event-consumers that dispatch events to one or more actions. The Kafka subscriber is an example of a trigger. Activity Interface a common interface for exposing common application logic in a reusable manner. Think of this as a function, such as write to database, publish to Kafka, etc that can be used by all Dovetail apps.  Repos Project Dovetail consists of the following sub-projects available as separate repos:\n dovetail-cli: Command line tools for building Dovetail apps \u0026amp; extensions dovetail-contrib: Dovetail contributions/extensions  Dovetail Flows Dovetail Flows provides smart contract logic design capabilities and includes the following key highlights.\nüåà Painless development Visual modeler with step-back debugging capabilities \u0026amp; elegant DSL ‚öôÔ∏è Ultra-light process engine for conditional flow control\nGetting Started We\u0026rsquo;ve made getting started with Dovetail Flows as easy as possible. The current set of tooling is designed for:\n Smart contract developers  For step by step instructions on how to get started please go to the documentation page\nZero-code Developers If your background is in or you prefer to develop your smart contracts using zero-coding environments, then read on, because we‚Äôve got something special for you.\nFlows Web UI is available via Dovetail releases page.\nTo report any issues with the Issue tracker on this project.\nContributing Want to contribute to Project Dovetail? We\u0026rsquo;ve made it easy, all you need to do is fork the repository you intend to contribute to, make your changes and create a Pull Request! Once the pull request has been created, you\u0026rsquo;ll be prompted to sign the CLA (Contributor License Agreement) online.\nNot sure where to start? No problem, here are a few suggestions:\n dovetail-contrib: This repository contains all of the contributions, such as activities, triggers, etc. Perhaps there is something missing? Create a new activity or trigger or fix a bug in an existing activity or trigger. Browse all of the Project Dovetail repositories and look for issues tagged kind/help-wanted or good first issue  If you have any questions, feel free to post an issue and tag it as a question or email tibcolabs@tibco.com.\nFor additional details, refer to the Contribution Guidelines.\nLicense The top level flogo repo, consisting of flow samples \u0026amp; documentation, is licensed licensed under a BSD-style license. Refer to LICENSE for license text.\nDovetail source code in dovetail-cli, dovetail-contrib, dovetail-java-lib are all licensed under a BSD-style license, refer to LICENSE\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/getting-started/",
	"title": "Getting started",
	"tags": [],
	"description": "",
	"content": " Getting started Getting started with Project Flogo!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/getting-started/quickstart/",
	"title": "Quickstart",
	"tags": [],
	"description": "",
	"content": "We think it is awesome that you want to get started with Project Flogo! To get started you don\u0026rsquo;t even need to install anything other than Docker!\n  Timers are great to schedule stuff, and a great way to learn new technology! Use this lab to get familiar with some of the concepts of Flogo!      Hello World! This lab will walk you through building your first API with Project Flogo     After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/getting-started/getting-started-webui/",
	"title": "Flogo Web UI",
	"tags": [],
	"description": "",
	"content": " Getting Started For an overview of how to get started, check out the Quickstart guide\nInstalling the Project Flogo Web UI Installing the Project Flogo Web UI is quite simple and requires nothing more than Docker pre-installed on your machine to fetch the Docker image.\nFetching and starting the Web UI To get started with the latest version of the Flogo Web UI paste this command in a terminal window:\ndocker run -it -p 3303:3303 flogo/flogo-docker:latest eula-accept\nLaunching the Web UI To launch Flogo WebUI simply open your favorite web browser, and navigate to http://localhost:3303. You\u0026rsquo;ll see our mascot Flynn there to greet you!\nRestarting the Web UI docker container After the Docker container has been shutdown, you may wish to simply restart the same container instance, rather than creating a new instance via the docker run command. You can easily do this by issuing the docker start command and reference the previously running container id. You can find the container name and id by using the command docker ps -a and searching for the container with the image flogo/flogo-docker. Use the ID (or name) associated with the image to issue the docker start command. For example:\ndocker start b24e4b9f3fa5\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/getting-started/getting-started-cli/",
	"title": "Flogo CLI",
	"tags": [],
	"description": "",
	"content": " Before you get started Before you can get started with the cli tools you need to make sure you the Go programming language installed.\nDon\u0026rsquo;t forget to set your GOPATH variable and make sure that $GOPATH/bin is part of your path. (see here or here for more details)\n Also make sure that you have installed dep dependency management tool.\nInstalling the cli tools Now that you\u0026rsquo;ve installed the Go programming language and dep there are a few commands you can run to install the cli and make developing with the cli tools even easier\n First you\u0026rsquo;ll need to go get flogo by running go get -u github.com/TIBCOSoftware/dovetail-cli/.... This will get you both the CLI tools. Second you can build the binary by running go install ./....  If you want to update the CLI tools, you can run go get -u github.com/TIBCOSoftware/flogo-cli/... to get the latest version and repeat dep ensure step.\n "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/network/",
	"title": "BlockChain Network",
	"tags": [],
	"description": "",
	"content": " Blockhain network Find all the relevtn informations for Corda and HyperLedger Fabric networks\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/",
	"title": "Labs",
	"tags": [],
	"description": "",
	"content": " Labs After getting up and running you might want to try your hand at some more advanced labs and tutorials. These labs provide you with a guides, tutorials and code samples and will help you work through building and deploying Flogo apps. The labs cover a wide range of topics like deploying to Kubernetes, using Flogo with the Serverless Framework and a bunch more! The colors of the cards have a meaning:\nDovetail‚Ñ¢ CLI These labs have an emphasis on using the Dovetail CLI to build apps\n Flogo CLI Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute. This tutorial covers the \u0026#39;flogo\u0026#39; command     Building activities Building new activities to extend the capabilities of Project Flogo is definitely not the most difficult thing on the planet. In fact, it\u0026#39;s rather easy to get you started!     Building triggers Triggers make it possible for Flogo to get data. How do you get started building a trigger, though? Check this tutorial to build a simple trigger.     Dovetail‚Ñ¢ Web UI These labs have an emphasis on using the Dovetail Web UI to build apps\n Hello World Hello World! This lab will walk you through building your first API with Project Flogo     Blockchain‚Ñ¢ tutorials These labs have an emphasis on using external tools together with Project Dovetail‚Ñ¢, like R3 Corda or Hyperledger Fabric on turn-key cloud solution such as Kubernetes\n Kubernetes Kubernetes is probably the most wellknown container orchestration platform out there. In this demo you explore how to run Flogo apps on Kubernetes.     TUTORIAL IOU smart contract application tutorial     "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/configuration/",
	"title": "Configuration",
	"tags": [],
	"description": "",
	"content": " Configuration Configurating the Dovetail‚Ñ¢ engine with environment variables and stuff :)\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/configuration/environment-vars/",
	"title": "Environment variables",
	"tags": [],
	"description": "",
	"content": "List of environment variables to configure the Dovetail‚Ñ¢ engine\n   Environment name Default value Info     FLOGO_LOG_DTFORMAT \u0026ldquo;2006-01-02 15:04:05.000\u0026rdquo; Sets the log date and time format   FLOGO_LOG_LEVEL \u0026ldquo;INFO\u0026rdquo; Sets the log level   FLOGO_RUNNER_TYPE \u0026ldquo;POOLED\u0026rdquo; Sets the type of the runner   FLOGO_RUNNER_WORKERS 5 Sets the number of workers   FLOGO_RUNNER_QUEUE 50 Sets the runner queue size   FLOGO_CONFIG_PATH \u0026ldquo;flogo.json\u0026rdquo; Sets the path of the config json file   FLOGO_ENGINE_STOP_ON_ERROR true Sets whether to stop the engine on error    "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/",
	"title": "Development",
	"tags": [],
	"description": "",
	"content": " Development All things Dovetail when it comes to building your smart contracts\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/apps/",
	"title": "Apps",
	"tags": [],
	"description": "",
	"content": " Apps Do you want to build apps and microservices? Want to better understand the concepts and constructs that make up a app? You\u0026rsquo;ve come to the right place!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/devenv/",
	"title": "Development Environment",
	"tags": [],
	"description": "",
	"content": " Get your environment ready All the necessary tasks, to get a clean and ready environment to build up samples, and new exciting features!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/apps/app-structure/",
	"title": "App structure",
	"tags": [],
	"description": "",
	"content": " Every Flogo app has the same basic structure and files for an application.\nmy_app/ flogo.json src/ my_app/ imports.go main.go vendor/  files The most important files are\n flogo.json : flogo project application configuration descriptor file imports.go : contains go imports for contributions (activities, triggers and models) used by the application main.go : main file for the engine.  directories The most important directories are\n src : the place where all code is stored vendor : the place where go libraries are stored  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/tensorflow/getting-started/",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " First and foremost, Flogo supports inferencing TensorFlow models, it does not support training of models using incoming data. The training should be performed in Python and the protobuf and checkpoints exported for inferencing at runtime in Flogo.\nBefore you can begin inferencing TensorFlow models within your Flogo Flows, you‚Äôll need to consider a few requirements.\nPre-requisites The TensorFlow dynamic lib must be installed on both your development machine, as well as the target machine/device. The dynlib must be built specifically for your platform architecture, that is, Linux Arm, x86, x64, Darwin, etc. Follow the instructions documented by TensorFlow, note that the only steps that you\u0026rsquo;ll need to follow are 2 and 3: downloading the correct dynamic lib and setting your lib paths. You do not need to \u0026lsquo;go get\u0026rsquo; TensorFlow.\nTensorFlow Models As previously stated, Flogo is leveraged to inference models at runtime, not train any models. Flogo includes a native activity to inference models. The activity has been developed and tested against the output of the tf.estimator API from TensorFlow.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/apps/app-configuration/",
	"title": "App Model",
	"tags": [],
	"description": "",
	"content": " Flogo Application Model The flogo.json file is the metadata describing an application. The application dictates the dependencies to be used during compile time and can also be embeded into the compiled binary.\n{ \u0026quot;name\u0026quot;: \u0026quot;myApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;My flogo application description\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;my_rest_trigger\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9233\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;actionId\u0026quot;: \u0026quot;my_simple_flow\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/test\u0026quot; } } ] } ], \u0026quot;actions\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;my_simple_flow\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flow\u0026quot;: { \u0026quot;attributes\u0026quot;: [], \u0026quot;rootTask\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;type\u0026quot;: 1, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: 2, \u0026quot;type\u0026quot;: 1, \u0026quot;activityRef\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;log\u0026quot;, \u0026quot;attributes\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;message\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;Simple Log\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] } ], \u0026quot;links\u0026quot;: [ ] } } } } ] }  Root Properties  name: The application name type: The type of application. Currently the only valid value is flogo:app  Triggers  id: the ID of the trigger settings: global settings for the trigger handlers the handlers for endpoints configured for the trigger  actionId: the ID of the action the handler invokes settings: the handler specific settings   "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/tensorflow/inferencing-tf/",
	"title": "Inferencing",
	"tags": [],
	"description": "",
	"content": " Before you begin with the ML Inferencing activity, refer to the Flows \u0026gt; TensorFlow \u0026gt; Getting Started documentation.\nOverview of the Inference Activity The inference activity was built to support the concept of plugable frameworks, however the only supported framework is currently TensorFlow. The activity leverages the Golang API from TensorFlow. You don\u0026rsquo;t need Python or anything other than the TensorFlow dynamic library installed on your dev \u0026amp; target machine.\nInputs model The model input to the activity should be either of the following:\n An archive (zip) of the model A directory containing the exported protobuf and check point files  The activity has been tested with the exported model from the tf.estimator.Exporter.export operation. After export, optionally zip the file, where the saved_model.pb file is located at the root of the archive.\nThe exported model from the tf.estimator package includes metadata defining the model. The signature_def element in the protobuf provides valuable data for inferencing the model that is leveraged by the Flogo activity. Some of the metadata includes\n the input key name, as well as the tensor (operation) to to be invoked. The input keyname is required as an input to the flogo activity the output keys, as well as the output tensors (which define the data types of the outputs). Multiple outputs can be present the method_name, such as classify, regression, etc  inputName The input key name for the input tensor. This can be fetched using the SavedModel CLI tools. Typically the name is \u0026ldquo;inputs\u0026rdquo;\nfeatures The features to pass into the SavedModel. This is of type object and should match the following format. Note that the input is a JSON object where the key is the feature name and the value is the value.\n{ \u0026quot;z-axis-q75\u0026quot;: 4.140586, \u0026quot;y-axis-q75\u0026quot;: 4.140586 }  framework The deep learning framework to use for inferencing. Currently the only supported value is: Tensorflow\nOutputs The output is an object and can contain multiple outputs. For example, for a classification model, the scores and classifications will ne held in a map:\nmap[scores:[[0.049997408 0.010411096 0.93959147]] classes:[[Jogging Sitting Upstairs]]]  Sample application Refer to the TensorFlow samples\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/apps/application-configuration-provider/",
	"title": "Application Configuration Provider",
	"tags": [],
	"description": "",
	"content": " Unless you want to provide the application configuration (for example: flogo.json) in a different way or format you should not worry about this feature.\nWe have provided an extension mechanism for you to override the default way of providing the application configuration if needed.\nTopics  Default behavior Embedded configuration Custom configuration  Default behavior Out of the box, the default behavior will be as follows:\n Configuration will be passed to the engine in the JSON format Default path for the JSON file will be in the same directory as the application\u0026rsquo;s binary Default name for the JSON file will be \u0026ldquo;flogo.json\u0026rdquo; Default path and name can be changed by setting an environment variable \u0026ldquo;flogo.config.path\u0026rdquo; (for example:)  # Example changing default configuration path and name $ export flogo.config.path=/path/to/config/myconfig.json  Embedded configuration There is an option when building the application to compile the flogo.json and embed it into the code instead of loading it from a file.\n# Example building the application in embedded mode $ flogo build -e  Custom configuration If you need to customize the way the configuration is provided to the engine (for example: \u0026ldquo;change the format of the configuration\u0026rdquo;), you just need to do the following: * Place a file in the \u0026ldquo;main\u0026rdquo; package of your application that looks like this:\npackage main import ( \u0026quot;github.com/TIBCOSoftware/flogo-lib/app\u0026quot; ) func init () { // The name of this variable is IMPORTANT as it is initializing an existing // variable in the main.go cp = MyProvider() } // myProvider implementation of ConfigProvider type myProvider struct { } //OptimizedProvider returns an app config from a compiled json file func MyProvider() (app.ConfigProvider){ return \u0026amp;myProvider{} } // GetApp returns the app configuration func (d *myProvider) GetApp() (*app.Config, error){ app := \u0026amp;app.Config{} // Add your own code here ... return app, nil }  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/apps/best-practices-app-development/",
	"title": "Best practices for app development",
	"tags": [],
	"description": "",
	"content": " There are a few best practices that we recommend when developing apps and functions using Flogo.\n.gitignore You definitely want to store your apps in a source control system and we recommend the the below template for your .gitignore for Flogo apps\n## Project Flogo .gitignore ## To restore all dependencies and prepare the project for build run ## the command `flogo ensure` ## bin folder is constructed using flogo build /bin ## pkg folder is constructed using flogo ensure /pkg ## vendor folder in src is constructed using flogo ensure /src/*/vendor  using the -flv flag With the flogo cli you\u0026rsquo;re usually on the latest tagged version of the main flogo repos. If you want to pick up the latest master branch, or a specific branch, you can use the -flv flag with flogo create. The flag wraps the dep command and since dep expects go code at the root of a repo, you\u0026rsquo;ll need to specify specify a package within that repo rather than the repo itself for the main flogo repositories:\n For flogo-contrib you can use github.com/TIBCOSoftware/flogo-contrib/action/flow@master For flogo-lib you can use github.com/TIBCOSoftware/flogo-lib/engine@master  You can replace master with any branch you want\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/",
	"title": "Flows",
	"tags": [],
	"description": "",
	"content": " Flows Do you want to build flows? Want to better understand the concepts and constructs that make up a flow, such as all the mapping types, valid syntax for mapping, etc? You\u0026rsquo;ve come to the right place!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/tensorflow/",
	"title": "TensorFlow",
	"tags": [],
	"description": "",
	"content": " TensorFlow Want to leverage TensorFlow within your Flogo Flows? Inference from per-built models to predict behavior and outcome to take action directly within your Flogo Flow.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/property-bag/",
	"title": "App Properties",
	"tags": [],
	"description": "",
	"content": " In Flogo, the concept of an application-level property bag is made available to flow developers that want to reuse properties across different flows, within the same application for trigger settings or as input to activities. Properties are exposed via the $property resolver and made available to the scopes defined in the mappings documentation.\nFlow configuration Properties are defined within the root of the application json, as shown below via the properties element.\n{ \u0026quot;name\u0026quot;: \u0026quot;default_app\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample flogo app\u0026quot;, \u0026quot;properties\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;my_property\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;My Property Value\u0026quot; } ]  As previously stated, properties are accessible via the $property resolver. Consider the following mappings into a log activity:\n{ \u0026quot;id\u0026quot;: \u0026quot;log_1\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Logger\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;type\u0026quot;: 1, \u0026quot;activityType\u0026quot;: \u0026quot;github-com-tibco-software-flogo-contrib-activity-log\u0026quot;, \u0026quot;activityRef\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;attributes\u0026quot;: [ ], \u0026quot;inputMappings\u0026quot;: [ { \u0026quot;type\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;$property[my_property]\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] }  Grouping of properties You can group related properties by using .\u0026hellip;.. naming convention.\n{ \u0026quot;name\u0026quot;: \u0026quot;default_app\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample flogo app\u0026quot;, \u0026quot;properties\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;PURCHASE.SERVICE.DB.URL\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;postgres://10.10.10.10:5370/mydb\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;PURCHASE.SERVICE.DB.USER\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;testuser\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;INVENTORY.SERVICE.DB.URL\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;postgres://10.10.10.20:5370/mydb\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;INVENTORY.SERVICE.DB.USER\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;testuser\u0026quot; } ]  These properties can be accessed via $property[PURCHASE.SERVICE.DB.URL] or $property[INVENTORY.SERVICE.DB.URL]\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/io-parameters/",
	"title": "Flow Input/Output Params",
	"tags": [],
	"description": "",
	"content": " For Flogo a Flow is more inline with the concept of a function, that is, a Flow has both input and output parameters. The concept of decoupling a trigger from a flow is a key part of supporting multiple triggers and re-use/sharing of a flow. A Flow can now operate against the data that it has defined within its declartion, it otherwords, just like a function, the scope of data that a Flow can operate against must reside within either the Flow context (or as an environment variable).\nSetting Flow Input and Output Params When building a Flow, you must first define the input and output params, that is, what are the input parameters that a flow can operate against and what parameters will be returned once the Flow has finished executing. To do this, we have options, either use the WebUI or construct the JSON manually.\nFrom the WebUI, open your new Flow, and click the \u0026ldquo;Flow Params\u0026rdquo; box, you\u0026rsquo;ll be presented with the Flow input/output editor.\nYou will be presented with a dialog containing two tabs, Input and Output. Use this dialog to define your input and output parameters.\nIf you intend to perform complex object mapping choose the type \u0026lsquo;object\u0026rsquo; for either an input or output param. This enables you to construct your own JSON, refer to the Flow Mappings section for details.\n If you\u0026rsquo;d prefer to define the Flows input and output params via the application JSON, you may do so\n\u0026quot;actions\u0026quot;: [ { \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;ISBN\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;someResponse\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot; } ] }  Mapping Trigger Output and Reply Because a Flow operates against its own locally scoped data (params), you will need to map the trigger data into the Flow params, as well as the flow params to the triggers reply params(s). This may sound a bit odd at first, however is required to ensure that a trigger is entierly decoupled from a flow, as previously said, enabling flows to be re-used and support multiple paths of invocation via different triggers.\nBefore we jump in, to understand the concepts used here:\n Trigger output: A trigger is an event-driven construct used to invoke a Flow. A trigger will run logic and perpare data that must be used within a Flow. Think of a REST trigger, the output of the trigger to the Flow will be things like the request data, the HTTP headers, etc. Trigger reply: After a Flow has finished executing, it may be desierable to send back data in response to the triggers request. Consider a REST trigger. If the verb was a GET, the reply would be the payload that the trigger must return to the caller.  To map the trigger data using the WebUI, add a trigger to your Flow, and click on it.\nNow select \u0026ldquo;Map flow params\u0026rdquo;.\nNow you can map the output of the trigger to Flow input params, and Flow output params can be mapped to the reply params available for the trigger.\nIf you choose to map directly within the JSON, consider the following triggers definition\n\u0026quot;triggers\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9099\u0026quot; }, \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;handlers\u0026quot;: [ { \u0026quot;actionMappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;ISBN\u0026quot;, \u0026quot;type\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;pathParams.ISBN\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;data\u0026quot;, \u0026quot;type\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;someResponse\u0026quot; } ] }, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/:ISBN\u0026quot;, \u0026quot;autoIdReply\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;useReplyHandler\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;actionId\u0026quot;: \u0026quot;my_flow\u0026quot; } ] } ]  Note the \u0026ldquo;actionMappings\u0026rdquo; within the handler settings.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/iterators/",
	"title": "Iterator",
	"tags": [],
	"description": "",
	"content": " What is an iterator in Flogo? The iterator construct in Flogo enables the iteration of a single activity. The configuration elements are associated with that activity. In Flogo, you can iterate only over a single activity. The iterator acts much like a for loop in any procedural language.\nFlow configuration Iterators are associated with an activity. The activity type must be defined as a type 2, which indicates that it is to be iterated over. Finally, a new settings element has been introduced, this is where you can define the array or literal to iterate over. Consider the JSON sample below of a log activity.\n{ \u0026quot;id\u0026quot;: \u0026quot;log_7\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;LogTitle\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;type\u0026quot;: 2, \u0026quot;activityType\u0026quot;: \u0026quot;github-com-tibco-software-flogo-contrib-activity-log\u0026quot;, \u0026quot;activityRef\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;attributes\u0026quot;: [ ], \u0026quot;inputMappings\u0026quot;: [ { \u0026quot;type\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;$current.iteration.value.volumeInfo.title\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ], \u0026quot;settings\u0026quot;: { \u0026quot;iterate\u0026quot;: \u0026quot;$activity[rest_3].result.items\u0026quot; } }  A few important things to note:\n The type is 2 A new settings element with a property named iterate set to the array that should be iterated over. It is also possible to define a static value, for example, if the value of \u0026ldquo;10\u0026rdquo; was specified, the iterator construct would invoke this activity 10 times The $current scope has not been introduced and can be used to access the value and key of the current iteration.  The $current scope has two properties:\n $current.iteration.value: The value of the current iteration, that is, the object of the current array $current.iteration.key: The current key (1, 2, etc)  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/flows/mapping/",
	"title": "Mappings",
	"tags": [],
	"description": "",
	"content": " What are mappings? A mapping in a Flogo Flow can be used to assign the value of a variable to that of an input parameters of an activity or to the value of another flow scoped variable.\nTypes of mappings If you peak under the covers, you\u0026rsquo;ll note that we have a number of different mapping types supported in the Flogo engine. These include:\n   Type Description     assign Direct mapping. Assigning the value from var1 to var2. No other implied logic.   literal A literal mapping. For example, mapping the string \u0026ldquo;hello\u0026rdquo; to a string typed variable.   expression Expression mapping. This enable using functions and expression condition in mamping   object Complex object. Used when a JSON-based complex object must be built and assigned.   array Array mapping. Mapping an Array of Objects.    Types manifest themselves directly in your application json, as follows:\n{ \u0026quot;mapTo\u0026quot;: \u0026quot;ISBN\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;evt.ISBN\u0026quot; }  The above mapping indicates that the value of evt.ISBN should be mapped to the variable named ISBN. This is a type assign mapping, hence the value of evt.ISBN is assigned directly to ISBN. Consider two additional samples, below you will find a type literal mapping, as well as a complex object type object mapping.\nType literal:\n{ \u0026quot;mapTo\u0026quot;: \u0026quot;ISBN\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;literal\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;12937\u0026quot; }  Type object:\n{ \u0026quot;mapTo\u0026quot;: \u0026quot;ISBN\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;value\u0026quot;: { \u0026quot;ISBN\u0026quot;: \u0026quot;12937\u0026quot;, \u0026quot;Author\u0026quot;: \u0026quot;{{$flow.Author}}\u0026quot; } }  The type literal mapping is pretty simple to understand, however type object does require a bit of an explanation. Note that the value param is assigned an object, not a string, and also note the use of the template style variable injection. You can use \u0026ldquo;{{ }}\u0026rdquo; when you need to inject the value of another object into your complex object. If you assign the value of an array then that param will be treated as an array, likewise for a string, int, etc. For example, let us pretend flow.Author is an array, then the Author object would be an array. In otherwords, direct assignment is occurring.\nThe WebUI insulates you frome much of this understanding and will infer the correct mapping type.\nType expression:\n{ \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.concat(\\\u0026quot;The pet category name is: \\\u0026quot;, $activity[rest_3].result.category.name)\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;data.description\u0026quot; }  The above sample leverages the output of a REST Invoke activity to get a pet from the public petstore service. The first mapper fetches the pet\u0026rsquo;s first[array index] id of tag and assigns the value to the id field of the data attribute and next mapper uses a string concat function string.concat(str1, str2, str3) and assigns function return to the description field.\nType array:\n{ \u0026quot;mapTo\u0026quot;: \u0026quot;data\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;array\u0026quot;, \u0026quot;value\u0026quot;: { \u0026quot;fields\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;$.id\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;$.id\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;primitive\u0026quot; }, { \u0026quot;from\u0026quot;: \u0026quot;$.name\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;$.name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;primitive\u0026quot; } ], \u0026quot;from\u0026quot;: \u0026quot;$activity[rest_3].result.tags\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;data.response\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;foreach\u0026quot; } }  To iterate over an array from the output of the previous activities or trigger to the current field of type array by supporting nested arrays and there are no limitation to how deep the array can be.\nThe $$ or $. indicates the current array element object, $.name to get current element\u0026rsquo;s name field.\nMapping Resolvers Flogo will resolve mappings with the following. Note the scopes table below, which indicates what objects are accessible within what scope.\n   Scope Description     $env Used to resolve an environment variable   $property Used to resolve properties from the global application property bag   $flow Used to resolve params from within the current flow. If a flow has a single trigger and no input params defined, then the output of the trigger is made available via $flow   $activity Used to resolve activity params. Activities are referenced by id, for example, $activity[acivity_id].activity_property.   $current Used to resolve data scoped to a current iterator    Mapping Scopes Flogo has the concept of mapping resolvers and resolvers are contained within a specific scope, hence not all objects can be accessed from anywhere within the scope.\n   Mapper Scope     Trigger-\u0026gt;Settings env and property resolvers   Trigger-\u0026gt;Handler-\u0026gt;Settings env and property resolvers   Trigger-\u0026gt;Handler-\u0026gt;actionMapper/input Trigger ouput \u0026lt;\u0026ndash; \u0026ldquo;value\u0026rdquo; field - only property and env resolver can be used. That is, only the output of the trigger or an environment variable can be used here.   Trigger-\u0026gt;Handler-\u0026gt;actionMapper/output action scope. Properties defined as ahe output of the flow can be used.   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper/input flow \u0026lt;\u0026ndash; \u0026ldquo;value\u0026rdquo; field - all resolvers can be used   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper/output activity input   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;outputMapper/input activity output   Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;outputMapper/output flow   Link Expression all resolvers can be used for link expressions.    Mapping Syntax Flogo leverages a few simple syntax paradigms when mapping. The first being, the $ character is used when accessing/reading someone not within the immediate scope. For example, consider the following mapping.\n\u0026quot;actionMappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;ISBN\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;pathParams.ISBN\u0026quot; } ]  The above mapping is from the Trigger/Handler, which we know, based on the resolver, we can only access trigger scoped (output) variables, thus pathParam is within the trigger scope and does not need any special characters when accessing.\nWhat is you\u0026rsquo;re accessing someone out of the immediate scope? The mapping should be prefixed with the $ special character, indicating to the resolver that we\u0026rsquo;re accessing someone out of the immediate scope. For example, consider the following.\n\u0026quot;inputMappings\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$flow.ISBN\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ]  This mapping is associated with Action-\u0026gt;Flow-\u0026gt;Activity-\u0026gt;inputMapper. We know that all resolvers can be used within the context, however none of the variables would be within the immediate scope, hence the $ should be used. For example, in the above snippet, we\u0026rsquo;re grabbing the value of the flow variable named ISBN, hence $flow.ISBN is used. If we wanted to grab the value of an environment variable we could use $env.VarName.\nAccessing object properties Most of the time you wont want to perform a direct assigning from one complex object to another, rather you\u0026rsquo;ll want to grab a simple type property from one complex object and perform a direct assigning to another property. This can be done accessing children using a simple dot notation. For example, consider the following mapping.\n{ \u0026quot;mapTo\u0026quot;: \u0026quot;someResponse\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;object\u0026quot;, \u0026quot;value\u0026quot;: { \u0026quot;Title\u0026quot;: \u0026quot;{{$activity[rest_3].result.items[0].volumeInfo.title}}\u0026quot;, \u0026quot;PublishedDate\u0026quot;: \u0026quot;{{$activity[rest_3].result.items[0].volumeInfo.publishedDate}}\u0026quot;, \u0026quot;Description\u0026quot;: \u0026quot;{{$activity[rest_3].result.items[0].volumeInfo.description}}\u0026quot; } }  First note that this is from a Return activity, which is mapping a complex object (type object) to a flow paramater named someResponse. The object we\u0026rsquo;re accessing is from the response of an activity, this is fetched using the $activity scope. Consider one of the examples:\n$activity[rest_3].result.items[0].volumeInfo.title\nWe\u0026rsquo;re referencing the result property from the activity named rest_3. We\u0026rsquo;re then accessing an items array (the first entry of the array) to another complex object, where finally we\u0026rsquo;re at a simple string property named title.\nUsing functions and expression Most of time you want to add some custome logic to the mapping, such as concat/substring/length of a string or generate a random number base on a range and so on. any logic you want to add you can come up with an function. Here are object exmaple of function we have today\n   Function Name Description Return Type     string.concat() Returns the concatenation of the arguments. You can concatenate two or more strings. Eg: string.concat(\u0026ldquo;Hello\u0026rdquo;,\u0026rsquo; \u0026lsquo;, \u0026ldquo;World\u0026rdquo;) string   string.equals() Returns whether those two string are equals. Eg: string.equals(\u0026ldquo;TIBCO FLOGO\u0026rdquo;, \u0026ldquo;TIBCO FLOGO\u0026rdquo;, false) boolean   string.length() Returns the length of a string. Eg: string.length(\u0026ldquo;TIBCO FLOGO\u0026rdquo;) integer   number.random() Generates a pseudo-random integer number between 0 and the specified limit. Eg: number.random(10) integer    { \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.concat(\\\u0026quot;The pet category name is: \\\u0026quot;, $activity[rest_3].result.category.name)\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;data.description\u0026quot; }  The function or expression condition can also use to link expreesion in branch, any functions that return a boolean can use in link expression.\n{ \u0026quot;from\u0026quot;: \u0026quot;rest_3\u0026quot;, \u0026quot;id\u0026quot;: 3, \u0026quot;to\u0026quot;: \u0026quot;log_5\u0026quot;, \u0026quot;type\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;$activity[rest_3].result.category.name == \\\u0026quot;BOOK\\\u0026quot;\u0026quot; } or { \u0026quot;from\u0026quot;: \u0026quot;rest_3\u0026quot;, \u0026quot;id\u0026quot;: 3, \u0026quot;to\u0026quot;: \u0026quot;log_5\u0026quot;, \u0026quot;type\u0026quot;: 1, \u0026quot;value\u0026quot;: \u0026quot;string.length($activity[rest_3].result.category.name) \u0026gt;= 10\u0026quot; }  Hanlding arrays in mappings There are lots of use cases for array mapping, map entire array to another or iterator partial array to another with functions The array mapping value comes from a JSON format\n{ \u0026quot;from\u0026quot;: \u0026quot;$activity[rest_3].result.tags\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;data.response\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;foreach\u0026quot;, \u0026quot;fields\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;$.id\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;$.id\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;primitive\u0026quot; }, { \u0026quot;from\u0026quot;: \u0026quot;string.concat($activity[rest_4].result.category.name, $.name)\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;$.name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;primitive\u0026quot; } ] }   from: Previous activity\u0026rsquo;s array output field to: current activity\u0026rsquo;s input array field type: foreach indicate iterator array element fields: list all element field that use to iterator and assign.  from: the value comes from to: to the current element, $. indicate current element. type: The type either primitive or foreach. foreach mean another array mapping. nest array support without deep limitation   If you want to only create one element of array. using NEWARRAY for from field.\n{ \u0026quot;fields\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;10001\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;$.id\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;primitive\u0026quot; }, { \u0026quot;from\u0026quot;: \u0026quot;$activity[rest].result.category.name\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;$.name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;primitive\u0026quot; } ], \u0026quot;from\u0026quot;: \u0026quot;NEWARRAY\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;data.response\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;foreach\u0026quot; }  Note: You can use any literal string, functions, expression in from under fields node.\nRecap  A mapping without a special character indicates a locally scoped object A mappig with the $ indicates an object outside of the current scope Flow properties are accessible via: $flow. Activity output properties/objects are accessible via: $activity[].property Envrionment variables are accessible via: $env  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/webui/",
	"title": "Web UI",
	"tags": [],
	"description": "",
	"content": " Web UI Building flows using the Web UI is awesome! Check out this section to see all the out of the box activities we have!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/webui/activities/",
	"title": "Activities",
	"tags": [],
	"description": "",
	"content": " Activities An activity is the unit of work that can be leveraged within a Flow. Here is the list of the out of the box activities. If it isn\u0026rsquo;t here, check the showcase to see the amazing contributions of our community\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/devenv/setup/",
	"title": "Setup your Dev environment",
	"tags": [],
	"description": "",
	"content": " Install Go and create workspace and setup GOPATH environment viarable as instructed Install Docker and Docker Compose Install Hyperledger Fabric Install Hyperledger Composer CLI Install Visio Studio Code and Hyperledger Composer plugin Install Maven  make sure you have access to following jars com.tibco.dovetail:dovetail-corda:0.0.1 is available here  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.jetbrains.kotlin\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;kotlin-stdlib-jre8\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.60\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.corda\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;corda-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.corda\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;corda-finance\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;[2.0.0,)\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.tibco.dovetail\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dovetail-corda\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   Install flogo-lib Install flogo-contrib Install go-bindata Intall govendor Install [Project Dovetail‚Ñ¢ Studio]()  after starting up the studio, you can upload contrib-smartcontract.zip from the Extensions tab  Install dovetail-cli  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/development/webui/triggers/",
	"title": "Triggers",
	"tags": [],
	"description": "",
	"content": " Triggers Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. . Here is the list of the out of the box activities. If it isn\u0026rsquo;t here, check the showcase to see the amazing contributions of our community\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/dovetail-cli/",
	"title": "Dovetail CLI Tools",
	"tags": [],
	"description": "",
	"content": " Dovetail CLI Discover the Dovetail CLI tools to build smart contracts.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/dovetail-cli/tools-overview/",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "Project Flogo provides different command-line interfaces and which you need depends on the task you need to execute.\n flogo: This CLI gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. flogodevice: This CLI gives you the ability to build your apps to run on different types of devices using the device profile option. flogogen: If you\u0026rsquo;re looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions.  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/dovetail-cli/dovetail-cli/",
	"title": "flogo",
	"tags": [],
	"description": "",
	"content": " The flogo CLI tool gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. It is also great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. Below is a complete list of all all commands supported, including samples on how to use them.\nPlease make sure that you have installed the flogo tools as described in Getting Started \u0026gt; Flogo CLI\n Commands build This command is used to build the application. The generation of metadata is done by default when doing a build, if you don\u0026rsquo;t want to regenerate the metadata use [-nogen] option.\nflogo build  options\n [ -o ] : optimize compilation, compiled application will only contain contribution directly referenced in the flogo.json [ -e ] : embeds the configuration into the compiled application [-nogen] : ONLY perform the build, without performing the generation of metadata [-gen] : ONLY perform generation of metadata, without performing the build [ -sp ] : [Deprecated, use \u0026lsquo;-nogen\u0026rsquo; instead] skip prepare step [ -shim ] : trigger shim creates an app as shim, pass trigger id as value (for example flogo build -shim my_trigger_id) [ -docker ] : creates a docker image of your app, where the docker image is based on Alpine Linux. This switch takes a single argument, a trigger ID for the port to expose. If you don\u0026rsquo;t want to expose any port specify \u0026lsquo;no-trigger\u0026rsquo;.  create This command is used to create a flogo application project.\nCreate the base sample project with a specific name.\nflogo create my_app  Create a flogo application project from an existing flogo application descriptor.\nflogo create -f myapp.json  Create a flogo application project using your own vendor directory.\nflogo create -vendor /path/to/my/vendor  Important, when using -vendor option use \u0026lsquo;flogo ensure -no-vendor\u0026rsquo; when updating dependencies to not override your imported vendor folder.\nCreate a flogo application project specifying constraints for your libraries.\nflogo create -flv github.com/TIBCOSoftware/flogo-lib@0.0.0,github.com/TIBCOSoftware/flogo-contrib@0.0.0  Pass a comma separated value of libraries and dependencies (you can also use branches and tags).\n ensure This command is used to manage project dependencies. It is mainly a wrapper for the \u0026lsquo;dep ensure\u0026rsquo; command for the official dep library\nflogo ensure  options\n [ -add ] : add new dependencies, or populate Gopkg.toml with constraints for existing dependencies (default: false) [ -no-vendor ] : update Gopkg.lock (if needed), but do not update vendor/ (default: false) [ -update ] : update the named dependencies (or all, if none are named) in Gopkg.lock to the latest allowed by Gopkg.toml (default: false) [ -v ] : enable verbose logging (default: false) [ -vendor-only ] : populate vendor/ from Gopkg.lock without updating it first (default: false)  help This command is used to display help on a particular command\nflogo help build  install This command is used to install a contribution to your project.\nInstall an activity using the latest version, or existing version constraint\nflogo install github.com/TIBCOSoftware/flogo-contrib/activity/log  Install an activity with a specific version constraint\nflogo install -v 0.0.0 github.com/TIBCOSoftware/flogo-contrib/activity/log  Note: if an existing constraint for the given package exist, the version will be ignored\nInstall a trigger the latest version, or existing version constraint\nflogo install github.com/TIBCOSoftware/flogo-contrib/trigger/rest  Install a trigger with a specific version constraint\nflogo install -v 0.0.0 github.com/TIBCOSoftware/flogo-contrib/trigger/rest  Note: if an existing constraint for the given package exist, the version will be ignored\nlist This command is used to list the activities, triggers and flows installed in the application.\nflogo list actions: github.com/TIBCOSoftware/flogo-contrib/action/flow activities: github.com/TIBCOSoftware/flogo-contrib/activity/log triggers: github.com/TIBCOSoftware/flogo-contrib/trigger/rest  The list can be generated in a JSON format using the \u0026lsquo;json\u0026rsquo; flag\nflogo list -json [ { \u0026quot;type\u0026quot;: \u0026quot;action\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot; }, { \u0026quot;type\u0026quot;: \u0026quot;activity\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot; }, { \u0026quot;type\u0026quot;: \u0026quot;trigger\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot; } ]  prepare Note: This command is deprecated! please use instead\nflogo build [-gen]  This command is used to prepare the application. Preparation consist of code generation for contribution metadata and go imports.\nflogo prepare  options\n [ -o ] : optimize compilation, compiled application will only contain contribution directly referenced in the flogo.json [ -e ] : embeds the configuration into the compiled application\n  uninstall This command is used to remove a contribution to your project.\nUninstall an activity\nflogo uninstall github.com/TIBCOSoftware/flogo-contrib/activity/log  Uninstall a trigger\nflogo uninstall github.com/TIBCOSoftware/flogo-contrib/trigger/rest  version This command displays the version of the flogo cli and the flogo-contrib and flogo-lib directories\nflogo version  If you run this action outside of the directory of a Flogo app you\u0026rsquo;ll see an error that this isn\u0026rsquo;t a valid project\nApplication Project Structure The create command creates a basic structure and files for an application.\nmy_app/ flogo.json src/ my_app/ vendor/ Gopkg.lock Gopkg.toml imports.go main.go  files\n flogo.json : flogo project application configuration descriptor file imports.go : contains go imports for contributions (activities, triggers and models) used by the application main.go : main file for the engine. Gopkg.toml : manifest file including dependency contraints and overrides. Gopkg.lock : lock file including the actual revision used according to the contraints.  directories\n vendor : go libraries  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/dovetail-cli/flogogen-cli/",
	"title": "flogogen",
	"tags": [],
	"description": "",
	"content": " The flogogen CLI tool is the tool you want to use if you\u0026rsquo;re looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions.. Below is a complete list of all all commands supported, including samples on how to use them.\nPlease make sure that you have installed the flogo tools as described in Getting Started \u0026gt; Flogo CLI\n action Create a custom flogo action.\nUsage: flogogen action ActionName ```\tRunning this command creates a basic structure and files for an action.  ActionName\naction.json action.go action_test.go\nThe three generated files contain data for your action * *action.json* : action project metadata json file * *action.go* : rudimentary action implementation in go * *action_test.go* : basic/initial test file for the action ## activity Ccreate a custom flogo activity.  Usage:\nflogogen activity ActivityName\n Running this command creates a basic structure and files for an activity.  ActivityName\nactivity.json activity.go activity_test.go\n The three generated files contain data for your activity * *activity.json* : activity project metadata json file * *activity.go* : rudimentary activity implementation in go * *activity_test.go* : basic/initial test file for the activity ## flowmodel Create a custom flogo flowmodel.  Usage:\nflogogen flowmodel MyFlowmodel\n Running this command creates a basic structure and files for a flowmodel.  MyFlowmodel\nflowmodel.json flowmodel.go flowmodel_test.go\n The three generated files contain data for your flowmodel - *flowmodel.json* : flowmodel project metadata json file - *flowmodel.go* : rudimentary flowmodel implementation in go - *flowmodel_test.go* : basic/initial test file for the flowmodel ## trigger Create a custom flogo trigger.  Usage:\nflogogen trigger MyTrigger\n Running this command creates a basic structure and files for a trigger.  MyTrigger\ntrigger.json trigger.go trigger_test.go ```\nThe three generated files contain data for your trigger\n trigger.json : trigger project metadata json file trigger.go : rudimentary trigger implementation in go trigger_test.go : basic/initial test file for the trigger  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/dovetail-cli/flogodevice-cli/",
	"title": "flogodevice",
	"tags": [],
	"description": "",
	"content": " The flogodevice CLI tool gives you the ability to build your apps to run on different types of devices using the device profile option. Below is a complete list of all all commands supported, including samples on how to use them.\nPlease make sure that you have installed the flogo tools as described in Getting Started \u0026gt; Flogo CLI and that PlatformIO is installed as well.\n build Build the flogo device application\nUsage: flogodevice build  create Create a device project\nUsage: flogodevice create  install Install a flogo device contribution\nUsage: flogodevice install  prepare Prepare the flogo device application\nUsage: flogodevice prepare  upload Upload the device application\nUsage: flogodevice upload  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/deployments/",
	"title": "Blockchain Deployments",
	"tags": [],
	"description": "",
	"content": " Deploy to any supported ledgers Dovetail can be used to deploy his smart contracts to pretty much any ledger platform that lead the marker today.\n  HyperLedger Fabroc is probably the most wellknown ledger platform for blockchain operations. In this demo you explore how to design and test a Dovetail smart contract against      Flogo apps are ultralight, so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small containers. Check out     After you\u0026rsquo;re done with these samples, why not check out the other labs we have for you!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/contributing/",
	"title": "Contribute",
	"tags": [],
	"description": "",
	"content": " Contribute Discover how you can contribute to Project Flogo!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/contributing/contributing/",
	"title": "Contributing to Project Flogo",
	"tags": [],
	"description": "",
	"content": " Are you interested in contributing to Project Dovetail? If so, this doc was created specifically for you! If you‚Äôre not ready to start contributing code, no problem, feel free to check out the documentation issues and begin by helping enhance the documentation!\nDetailed instructions on contributing to the documentation and sharing your projects via the showcase can be found in our documentation, here:\nhttp://dovetail.io.s3-website-us-east-1.amazonaws.com/contributing/\nIf you‚Äôre ready and interested to make code contributions, we‚Äôve tried to make the process as easy as possible. First, an automated contributor license agreement (CLA) has been put in place, after your first pull request, you‚Äôll be prompted to sign the agreement, no hassles, easy and integrated right into GitHub. Also, before you begin, take a look at the general guidelines below for contributing.\nHow do I make a contribution? Never made an open source contribution before? Wondering how contributions work in our project? Here\u0026rsquo;s a quick rundown!\nIf you have any questions, feel free to post an issue and tag it as a question, email Dovetail-oss@tibco.com or chat with the team and community:\n The project-Dovetail/Lobby Gitter channel should be used for general discussions, start here for all things Dovetail! The project-Dovetail/developers Gitter channel should be used for developer/contributor focused conversations.\n Find an issue that you are interested in addressing or a feature that you would like to add. Look for issues labeled good first issue, kind/help-wanted if you‚Äôre unsure where to begin. Don‚Äôt forget to checkout all of the Dovetail repositories: Dovetail-contrib, Dovetail-cli.\n Fork the repository associated with the issue to your local GitHub account. This means that you will have a copy of the repository under github-username/repository-name.\n Clone the repository to your local machine using git clone https://github.com/github-username/repository-name.git.\n Create a new branch for your fix using git checkout -b branch-name-here.\n Make the appropriate changes for the issue you are trying to address or the feature that you want to add.\n Use git add insert-paths-of-changed-files-here to add the file contents of the changed files to the \u0026ldquo;snapshot\u0026rdquo; git uses to manage the state of the project, also known as the index.\n Use git commit -m \u0026quot;Insert a short message of the changes made here\u0026quot; to store the contents of the index with a descriptive message.\n Push the changes to the remote repository using git push origin branch-name-here.\n Submit a pull request to the upstream repository.\n Title the pull request with a short description of the changes made and the issue or bug number associated with your change. For example, you can title an issue like: \u0026ldquo;Registering mapper functions as outlined in #4352\u0026rdquo;.\n In the description of the pull request, explain the changes that you made, any issues you think exist with the pull request you made, and any questions you have for the maintainers.\n Sign the CLA if you have not yet done so in the past.\n Wait for the pull request to be reviewed by a maintainers.\n Make changes to the pull request if the reviewing maintainer recommends them.\n Congratulations, you‚Äôve contributed to Project Dovetail, a celebration is in order!\n  Best Practices for Code Contributions If you\u0026rsquo;re adding a new feature, such as an activity or trigger, please follow the best practices below:\n Provide test cases for your feature Package name should match your activity dir. For example, if a new activity is placed in activity/awesomeActivity then the go package name should match.  Follow Go best practices for package names: https://blog.golang.org/package-names  Run gofmt to format your code Leverage activity trigger metadata (activity/trigger.json)  Use metadata ‚Äòrequired‚Äô attribute when the attribute is required Supply a default value in metadata not code (use the value attribute)  Activity Eval() should return true only when completed successfully \u0026amp; err should be returned when an error occurs  Refer to the Dovetail Documentation for more guidence and help.\nDon\u0026rsquo;t forget, if you build an awesome Activity or Trigger you can share your work via the Dovetail Showcase rather than contributing to Dovetail-contrib.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/contributing/contribute-to-docs/",
	"title": "Building the docs website",
	"tags": [],
	"description": "",
	"content": " If you want to contribute to the documentation, that is awesome! Your help is very much appreciated, but please do keep in mind the instructions below.\nPrerequisites These documentation pages are built with Hugo and we do make some assumptions:\n You have Git 2.5 or greater installed on your machine. You have a GitHub account. Signing up for GitHub is free. You have Hugo installed on your machine.  In Hugo, pages are the core of your site. Once it is configured, pages are definitely the added value to your documentation site.\nFolders Organize your site like any other Hugo project. Typically, you will have a content folder with all your pages.\ncontent ‚îú‚îÄ‚îÄ level-one ‚îÇ ‚îú‚îÄ‚îÄ level-two ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ level-three ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ level-four ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one/level-two/level-three/level-four ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-4-a.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-a ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-4-b.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-b ‚îÇ ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page-4-c.md \u0026lt;-- /level-one/level-two/level-three/level-four/page-4-c ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one/level-two/level-three ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-3-a.md \u0026lt;-- /level-one/level-two/level-three/page-3-a ‚îÇ ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-3-b.md \u0026lt;-- /level-one/level-two/level-three/page-3-b ‚îÇ ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page-3-c.md \u0026lt;-- /level-one/level-two/level-three/page-3-c ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one/level-two ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-2-a.md \u0026lt;-- /level-one/level-two/page-2-a ‚îÇ ‚îÇ ‚îú‚îÄ‚îÄ page-2-b.md \u0026lt;-- /level-one/level-two/page-2-b ‚îÇ ‚îÇ ‚îî‚îÄ‚îÄ page-2-c.md \u0026lt;-- /level-one/level-two/page-2-c ‚îÇ ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- /level-one ‚îÇ ‚îú‚îÄ‚îÄ page-1-a.md \u0026lt;-- /level-one/page-1-a ‚îÇ ‚îú‚îÄ‚îÄ page-1-b.md \u0026lt;-- /level-one/page-1-b ‚îÇ ‚îî‚îÄ‚îÄ page-1-c.md \u0026lt;-- /level-one/page-1-c ‚îú‚îÄ‚îÄ _index.md \u0026lt;-- / ‚îî‚îÄ‚îÄ page-top.md \u0026lt;-- /page-top  _index.md is required in each folder, it‚Äôs your ‚Äúfolder home page‚Äù\n Pages The theme that we\u0026rsquo;re using defines two types of pages. Default and Chapter. Both can be used at any level of the documentation, the only difference being layout display.\nChapters A Chapter displays a page meant to be used as introduction for a set of child pages. Commonly, it contains a simple title and a catch line to define content that can be found under it.\n--- title: Contribute weight: 2 chapter: true --- ### Chapter 2 # Contribute Discover how you can contribute!  To consider a page as a chapter, set chapter=true in the Front Matter of the page.\nDefault pages A Default page is any other content page.\n--- date: 2016-04-09T16:50:16+02:00 title: Advanced display configuration options weight: 40 --- ## Advanced configuration options  Content Now you can add your content (or update existing ones) to the pages that you want.\nBuilding the docs website In order to build and submit your changes, please follow the instructions below:\n Fork the flogo repo Update the docs with your content Create a PR against the flogo repo  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/contributing/contribute-to-showcase/",
	"title": "Contributing to the Showcase",
	"tags": [],
	"description": "",
	"content": " Have an activity, trigger or app that you want to share with the Flogo comunity? That\u0026rsquo;s awesome! To contribute to the showcase follow the steps below.\nFolders The showcase is located at the root of the flogo repo and is structured as follows.\nshowcases ‚îú‚îÄ‚îÄ data ‚îÇ ‚îú‚îÄ‚îÄ items.toml \u0026lt;-- the showcase data file  items.toml is the file that you\u0026rsquo;ll need to edit to add your activity, trigger or app.\n Adding your contribution After you\u0026rsquo;ve forked the flogo repo and cloned it to your local machine, open showcases/data/items.toml in your favorite text editor. You can search to see if your contribution has been listed already or simply append your specific contribution, as shown below.\n[[items]] name = \u0026quot;Aggregate\u0026quot; type = \u0026quot;activity\u0026quot; description = \u0026quot;This activity provides your flogo application with rudimentary aggregation capabilities.\u0026quot; url = \u0026quot;https://github.com/TIBCOSoftware/flogo-contrib/tree/master/activity/aggregate\u0026quot; uploadedon = \u0026quot;January 8, 2018\u0026quot; author = \u0026quot;TIBCOSoftware\u0026quot; showcase = \u0026quot;true\u0026quot;   Enter your contribution name Specify the type: activity, trigger or app Supply a short description Provide the GitHub url Specify your uploaded date Provide your github id display your contribution in the showcase  Building the showcase In order to build and submit your changes, please follow the instructions below:\n Fork the flogo repo Update the showcase with your content, as shown above Create a PR against the flogo repo  Automatic updates Flogo checks for activity updates and new activities once per day and automatically adds them to the items.toml file. By default new additions will not be visible in the showcase, unless the author of the contribution submits a PR to the Flogo repository to do so. Flogo automatically removes contributions that are no longer on GitHub.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/glossary/",
	"title": "Glossary",
	"tags": [],
	"description": "",
	"content": " Flogo terminology and constructs, defined here, all in one place in a logical order vs alphabetical.\nApp An application in Flogo terms is comprised of one or more triggers and flows (actions). The application itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An application contains a set of configurations, as well as triggers and a collection of flows.\nTrigger Flogo is an event-driven framework. A trigger is the entrypoint for events. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nTriggers are not coupled to flows, that is, a flow can exist without a trigger.\nHandlers The trigger handler is used to map triggers to actions (flows) for processing. A trigger can have one or more handlers that can route events to different flows.\nAction As stated in the triggers section above, Flogo is an event-driven framework. Incoming events can be mapped to an action. An action is a generic implementation for processing the incoming event. Different types of actions can be implemented, thus defining different methods by which an incoming event can be processed.\nToday, only a single action type has been implemented - the Flow.\nFlow A flow is an implementation of an action and is the primary tool to implement business logic in Flogo. A flow can consist of a number of different constructs:\n One or more activities that implement specific logic (for example write to a database, invoke a REST endpoint, etc) Each activity is connected via a link Links can contain conditional logic to alter the path of a flow  Flows, as previously stated in the triggers section, can exist without a trigger. Thus, flows operate very similar to functions, that is, a single flow can define its own input \u0026amp; output parameters. Thus, enabling a flow to be reused regardless of the trigger entrypoint. All logic in the flow only operates against the following data:\n Flow input parameters Environment variables Application properties The output data from activities referenced in the flow  The flow cannot access trigger data directly, trigger input and output data must be mapped into the flows input and output parameters. Refer to Development \u0026gt; Flows \u0026gt; Mappings\nMapping The phrase mapping occurs quite often and refers to the concept of taking properties from one object and associating them with properties of another object. For example, consider object A exposes two properties and activity B accepts only a single input parameter, the two properties need to be concatenated (for example) and \u0026lsquo;mapped\u0026rsquo; into the single input of activity B.\nActivity An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Project Dovetail‚Ñ¢ Docs and Tutorials for project Dovetail‚Ñ¢\nGet started...  I\u0026#39;m an Business Developer!\n    I\u0026#39;m a Go Developer!\n    I need help!\n     As an Business Developer you might want to try...\n Our quickstart\n    Getting started with the UI\n    Check out some labs on Blockchain\n    HyperLedger Fabric‚Ñ¢ : in this demo you explore how to design and test a Dovetail‚Ñ¢ smart contract against Hyperledger Fabric‚Ñ¢.\n    R3 Corda : in this demo you explore how to design and test a Dovetail‚Ñ¢ smart contract against Corda‚Ñ¢.\n     As an Go Developer you might want to try...\n Mapping some fields\n      If you have any questions, feel free to post an issue and tag it as a question, email flogo-oss at tibco dot com or chat with the team and community in:\n Come join our Gitter channel to talk all things Flogo!\n    Join this Gitter channel for developer questions!\n      function show(arg) { document.getElementById(\"app\").classList = \"line hidden\" document.getElementById(\"golang\").classList = \"line hidden\" document.getElementById(\"docs\").classList = \"line hidden\" document.getElementById(\"talk\").classList = \"line hidden\" document.getElementById(arg).classList.remove(\"hidden\") document.getElementById(arg).classList.add(\"block\") }  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/dovetail-cli/flogo-cli/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "THIS PAGE IS AUTOMATICALLY GENERATED DURING BUILD\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/flogo-cli/",
	"title": "Building apps with Flogo CLI",
	"tags": [],
	"description": "",
	"content": " Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute.\n flogo: This CLI gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. flogogen: If you‚Äôre looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions.  In this tutorial you will learn how to use the first of the two CLI tools\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you.\nNow you can copy the contents below to the newly created flogo.json file. The Flogo app has a REST trigger which listens on port 9233 and the HTTP path /test/:name (where :name is a parameter you can fill in).\n{ \u0026quot;name\u0026quot;: \u0026quot;Tutorial\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: \u0026quot;9233\u0026quot; }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:http_flow\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.pathParams.name\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;mapTo\u0026quot;: \u0026quot;data\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$.greeting\u0026quot; }, { \u0026quot;mapTo\u0026quot;: \u0026quot;code\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;literal\u0026quot;, \u0026quot;value\u0026quot;: 200 } ] } }, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/test/:name\u0026quot; } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:http_flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;HTTPFlow\u0026quot;, \u0026quot;metadata\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;greeting\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] }, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;message\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;flowInfo\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] } } }, { \u0026quot;id\u0026quot;: \u0026quot;actreturn_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Return\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Return Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/actreturn\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;mappings\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;expression\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;string.concat(\\\u0026quot;Hello \\\u0026quot;, $flow.name)\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;greeting\u0026quot; } ] } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;log_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;actreturn_3\u0026quot; } ] } } ] }  Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started  To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:9233/test/flogo. It will send an HTTP request to the app on port 9233 (which was configured in the flogo.json file). In the second terminal you will see the result of the flow (Hello flogo) and when you go back to the first terminal you had, you\u0026rsquo;ll see there are additional lines in your window that indicate a flow has been executed. Now try it out with your own name and see what happens :)\n2018-05-12 04:35:00.632 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-05-12 04:35:00.632 INFO [engine] - Running FlowAction for URI: 'res://flow:http_flow' 2018-05-12 04:35:00.633 INFO [activity-flogo-log] - Hello flogo 2018-05-12 04:35:00.633 INFO [engine] - Flow instance [29db1cc55a96c27c280227b2d7b8be82] Completed Successfully 2018-05-12 04:35:15.364 INFO [trigger-flogo-rest] - Received request for id 'receive_http_message' 2018-05-12 04:35:15.364 INFO [engine] - Running FlowAction for URI: 'res://flow:http_flow' 2018-05-12 04:35:15.364 INFO [activity-flogo-log] - Hello leon 2018-05-12 04:35:15.365 INFO [engine] - Flow instance [2adb1cc55a96c27c280227b2d7b8be82] Completed Successfully  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/building-activities/",
	"title": "Building your first activity",
	"tags": [],
	"description": "",
	"content": " Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute.\n flogo: This CLI gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. flogogen: If you‚Äôre looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions.  In this tutorial you will learn how to use the flogogen tool.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Generate the basic framework The easiest way to start creating activities is to have the flogogen CLI create the basic framework for you. The flogogen CLI takes two important parameters to create the framework for activities. In this tutorial you\u0026rsquo;ll build an activity that takes 2 input parameters (name and salutation) and logs that to the console. It will also return the concatenation of the two fields to you. To start you need to use flogogen to create the scaffolding:\nflogogen activity \u0026lt; name \u0026gt;  The parameters are:\n activity: because you want to create an activity \u0026lt; name \u0026gt;: the name for your new activity (in this example you\u0026rsquo;ll use HelloWorld as the name for the activity)  So to generate our scaffolding, you need to execute the command:\nflogogen activity HelloWorld  The flogogen command will create a folder called HelloWorld and generate the files you need to implement your logic:\nHelloWorld ‚îú‚îÄ‚îÄ activity.go \u0026lt;-- The implementation of your activity ‚îú‚îÄ‚îÄ activity.json \u0026lt;-- The metadata of your activity ‚îî‚îÄ‚îÄ activity_test.go \u0026lt;-- A file used to test your activity  The metadata The first step is to update the file activity.json, which has the metadata for your new Flogo activity, with proper information. The metadata describes to the Flogo engine what the activity is called, what the version of the activity is and a few other things. The elements in the file are:\n name: The name of the activity (this should match the name of the folder the activity is in, like HelloWorld) version: The version of the activity (it is recommended to use semantic versioning for your activities) type: This describes to the Flogo engine what kind of contribution this is (this should be activity in this case) ref: The Flogo engine is based on Go and this field is the \u0026ldquo;import\u0026rdquo; path for Go apps (generally speaking this should match your repository) description: A brief description of your activity (this is displayed in the Flogo Web UI) author: This is you! inputs: An array of name/type pairs that describe the input to the activity outputs: An array of name/type pairs that describe the output to the activity  Since you\u0026rsquo;ll want to provide some inputs, you\u0026rsquo;ll need to update the inputs and outputs section\n The inputs section needs a salutation and name (both should be of type string) The outputs section needs a parameter called result (should be of type string)  Don\u0026rsquo;t forget to update the author, ref, and description fields, as well!\n The updated activity.json will look quite similar to the below one.\n{ \u0026quot;name\u0026quot;: \u0026quot;HelloWorld\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:activity\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/yourusername/yourrepository\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Say Hello World!\u0026quot;, \u0026quot;author\u0026quot;: \u0026quot;Flogo Developer\u0026quot;, \u0026quot;inputs\u0026quot;:[ { \u0026quot;name\u0026quot;: \u0026quot;salutation\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; }, { \u0026quot;name\u0026quot;: \u0026quot;name\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;outputs\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;result\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] }  The logic For the Flogo engine to actually do something we need to update the *.go files. There are two files in your current directory:\n activity.go: which contains the actual activity implementation in go activity_test.go: which contains unit tests for the activity  The first step is to look at the business logic, in the activity.go file.\nAs you want to log the output to the console you\u0026rsquo;ll need to import a new Go package github.com/TIBCOSoftware/flogo-lib/logger and add a new variable called log to the main part of the file\nvar log = logger.GetLogger(\u0026quot;activity-helloworld\u0026quot;)  For the activity itself the only mandatory function that needs to be implemented is the Eval() method. In that method you\u0026rsquo;ll need to add two lines of code to get the name and salutation from the process context.\nname := context.GetInput(\u0026quot;name\u0026quot;).(string) salutation := context.GetInput(\u0026quot;salutation\u0026quot;).(string)  The next step is to log it to the console\nlog.Infof(\u0026quot;The Flogo engine says [%s] to [%s]\u0026quot;, salutation, name)  And finally set the output\ncontext.SetOutput(\u0026quot;result\u0026quot;, \u0026quot;The Flogo engine says \u0026quot;+salutation+\u0026quot; to \u0026quot;+name)  All together your activity.go file should look something like the one below:\npackage HelloWorld import ( \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/activity\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; ) // THIS IS ADDED // log is the default package logger which we'll use to log var log = logger.GetLogger(\u0026quot;activity-helloworld\u0026quot;) // MyActivity is a stub for your Activity implementation type MyActivity struct { metadata *activity.Metadata } // NewActivity creates a new activity func NewActivity(metadata *activity.Metadata) activity.Activity { return \u0026amp;MyActivity{metadata: metadata} } // Metadata implements activity.Activity.Metadata func (a *MyActivity) Metadata() *activity.Metadata { return a.metadata } // THIS HAS CHANGED // Eval implements activity.Activity.Eval func (a *MyActivity) Eval(context activity.Context) (done bool, err error) { // Get the activity data from the context name := context.GetInput(\u0026quot;name\u0026quot;).(string) salutation := context.GetInput(\u0026quot;salutation\u0026quot;).(string) // Use the log object to log the greeting log.Infof(\u0026quot;The Flogo engine says [%s] to [%s]\u0026quot;, salutation, name) // Set the result as part of the context context.SetOutput(\u0026quot;result\u0026quot;, \u0026quot;The Flogo engine says \u0026quot;+salutation+\u0026quot; to \u0026quot;+name) // Signal to the Flogo engine that the activity is completed return true, nil }  To make sure that you can test and build the new activity, you\u0026rsquo;ll need to go get (pun intended) a few packages\ngo get github.com/TIBCOSoftware/flogo-lib/core/activity go get github.com/TIBCOSoftware/flogo-lib/logger  Unit testing You\u0026rsquo;ve just completed the logic of the activity and, following best practice, you should have an automated way to test the activity to make sure that the it works and so that other developers can run the same tests to validate the output as well. The functions getActivityMetadata and TestCreate are default methods and the TestEval is the one you\u0026rsquo;ll need to update. You\u0026rsquo;ll want to compare the output with the expected output so you\u0026rsquo;ll need to add a new import\n\u0026quot;github.com/stretchr/testify/assert\u0026quot;  Since the engine will still expect inputs, you\u0026rsquo;ll need to hard code them into the method and execute the eval method of the activity\n//setup attrs tc.SetInput(\u0026quot;name\u0026quot;, \u0026quot;Flogo Dev\u0026quot;) tc.SetInput(\u0026quot;salutation\u0026quot;, \u0026quot;Hello\u0026quot;) act.Eval(tc)  To make sure that the fields are properly concatenated, you need to validate the output too:\n//check result attr result := tc.GetOutput(\u0026quot;result\u0026quot;) assert.Equal(t, result, \u0026quot;The Flogo engine says Hello to Flogo Dev\u0026quot;)  The updated file will look something like the one below:\npackage HelloWorld import ( \u0026quot;io/ioutil\u0026quot; \u0026quot;testing\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow/test\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/activity\u0026quot; \u0026quot;github.com/stretchr/testify/assert\u0026quot; ) var activityMetadata *activity.Metadata func getActivityMetadata() *activity.Metadata { if activityMetadata == nil { jsonMetadataBytes, err := ioutil.ReadFile(\u0026quot;activity.json\u0026quot;) if err != nil { panic(\u0026quot;No Json Metadata found for activity.json path\u0026quot;) } activityMetadata = activity.NewMetadata(string(jsonMetadataBytes)) } return activityMetadata } func TestCreate(t *testing.T) { act := NewActivity(getActivityMetadata()) if act == nil { t.Error(\u0026quot;Activity Not Created\u0026quot;) t.Fail() return } } func TestEval(t *testing.T) { defer func() { if r := recover(); r != nil { t.Failed() t.Errorf(\u0026quot;panic during execution: %v\u0026quot;, r) } }() act := NewActivity(getActivityMetadata()) tc := test.NewTestActivityContext(getActivityMetadata()) //setup attrs tc.SetInput(\u0026quot;name\u0026quot;, \u0026quot;Leon\u0026quot;) tc.SetInput(\u0026quot;salutation\u0026quot;, \u0026quot;Hello\u0026quot;) act.Eval(tc) //check result attr result := tc.GetOutput(\u0026quot;result\u0026quot;) assert.Equal(t, result, \u0026quot;The Flogo engine says Hello to Flogo Dev\u0026quot;) }  In order to run the test cases you\u0026rsquo;ll need to intall two more packages. One to be able to tun the tests and one to be able to create assertions.\ngo get github.com/TIBCOSoftware/flogo-contrib/action/flow/test go get github.com/stretchr/testify/assert  To run all the test cases for your activity, in this case just one, simply enter\ngo test  and if all goes well the result should look like\nPASS ok _/C_/tools/gosrc/HelloWorld 0.051s  Use your new activity in a flow Now the only thing left to do is use the activity inside a Flogo app! You have two options, install the new activity using the Flogo CLI or via the Web UI. In any case you\u0026rsquo;ll first want to publish your activity to a Git repo (the same one you\u0026rsquo;ve used in the ref field in the activity.json). To add the new activity to a Flogo engine and use it in a flow you can import it using the following flogo CLI command, from your flow app directory):\nflogo install github.com/yourusername/yourrepository  or import it using the \u0026ldquo;Install new activity\u0026rdquo; option in the Flogo Web UI, where you\u0026rsquo;ll need to provide the URL https://github.com/yourusername/yourrepository.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/building-triggers/",
	"title": "Building your first trigger",
	"tags": [],
	"description": "",
	"content": " Project Flogo provides two different command-line interfaces and which you need depends on the task you need to execute.\n flogo: This CLI gives you the ability to build flows and microservices. With this tool you can, among other things, create your applications, build applications and install new extensions. This tool is great to use with Continuous Integration and Continuous Deployment tools like Jenkins and Travis-CI. flogogen: If you‚Äôre looking to extend the functionality that Project Flogo offers out of the box, this is the tool you want to use. Flogogen generates the scafolding used by extensions (activity/trigger) developers to build new extensions.  In this tutorial you will learn how to use the flogogen tool.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Generate the basic framework The easiest way to start creating activities is to have the flogogen CLI create the basic framework for you. The flogogen CLI takes two important parameters to create the framework for triggers. Timers are great to schedule stuff, and a great way to learn new technology, so in this tutorial you\u0026rsquo;ll build a new timer trigger that runs on a specified interval. To start you need to use flogogen to create the scaffolding:\nflogogen trigger \u0026lt; name \u0026gt;  The parameters are:\n trigger: because you want to create a trigger \u0026lt; name \u0026gt;: the name for your new trigger (in this example you\u0026rsquo;ll use MyTimerTrigger as the name for the trigger to make sure it doesn\u0026rsquo;t clash with the existing timer)  So to generate our scaffolding, you need to execute the command:\nflogogen trigger MyTimerTrigger  The flogogen command will create a folder called MyTimerTrigger and generate the files you need to implement your logic:\nMyTimerTrigger ‚îú‚îÄ‚îÄ trigger.go \u0026lt;-- The implementation of your trigger ‚îú‚îÄ‚îÄ trigger.json \u0026lt;-- The metadata of your trigger ‚îî‚îÄ‚îÄ trigger_test.go \u0026lt;-- A file used to test your trigger  The metadata The first step is to update the file activity.json, which has the metadata for your new Flogo activity, with proper information. The metadata describes to the Flogo engine what the activity is called, what the version of the activity is and a few other things. The elements in the file are:\n name: The name of the activity (this should match the name of the folder the activity is in, like MyTimerTrigger) version: The version of the activity (it is recommended to use semantic versioning for your trigger) type: This describes to the Flogo engine what kind of contribution this is (this should be trigger in this case) ref: The Flogo engine is based on Go and this field is the \u0026ldquo;import\u0026rdquo; path for Go apps (generally speaking this should match your repository) description: A brief description of your activity (this is displayed in the Flogo Web UI) author: This is you! settings: An array of name/type pairs that describe global settings of the trigger (configuration that will be the same for every instance of this trigger used in your app) output: An array of name/type pairs that describe the output of the trigger (the data that gets sent to your flow) handler: An array of name/type pairs that describe flow specific settings of the trigger (configuration that will be unique for every instance of this trigger used in your app)  Since you\u0026rsquo;ll want to provide some configuration, you\u0026rsquo;ll need to update the outputs section\n The settings section will be left empty (you\u0026rsquo;ll use flow specific settings) The output section needs a parameter called output (should be of type string) The handler/settings section needs a parameter called seconds (should be of type string)  Don\u0026rsquo;t forget to update the author, ref, and description fields, as well!\n The updated trigger.json will look quite similar to the below one.\n{ \u0026quot;name\u0026quot;: \u0026quot;MyTimerTrigger\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:trigger\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;This is a new Timer\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/yourusername/yourrepository\u0026quot;, \u0026quot;author\u0026quot;: \u0026quot;Flogo Dev\u0026quot;, \u0026quot;settings\u0026quot;:[ ], \u0026quot;output\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;output\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ], \u0026quot;handler\u0026quot;: { \u0026quot;settings\u0026quot;: [ { \u0026quot;name\u0026quot;: \u0026quot;seconds\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;string\u0026quot; } ] } }  The logic For the Flogo engine to actually do something we need to update the *.go files. There are two files in your current directory:\n trigger.go: which contains the actual trigger implementation in go trigger_test.go: which contains unit tests for the trigger  The first step is to look at the business logic, in the trigger.go file.\nTo begin there are a few packages you\u0026rsquo;ll need to import to make sure the code will work:\n\u0026quot;context\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/trigger\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; \u0026quot;github.com/carlescere/scheduler\u0026quot;  As you want to log output to the console you\u0026rsquo;ll need to add a new variable called log to the main part of the file\n// Create a new logger var log = logger.GetLogger(\u0026quot;trigger-mytrigger\u0026quot;)  The struct called MyTrigger needs a few more fields to keep track of all the different elements it needs to know about. You\u0026rsquo;ll need to add the timers and handlers so that the engine knows which timers exist and which flows to call when a timer runs.\n// MyTrigger is a stub for your Trigger implementation type MyTrigger struct { metadata *trigger.Metadata config *trigger.Config timers []*scheduler.Job handlers []*trigger.Handler }  In the Initialize method you\u0026rsquo;ll need to add one statement to make sure that the trigger can get all the handlers it should know about from the context object.\nt.handlers = ctx.GetHandlers()  The Start method implements the logic required to start the various timers you might create in your app and for each it will schedule a job (using the scheduleRepeating method)\n// Start implements trigger.Trigger.Start func (t *MyTrigger) Start() error { log.Debug(\u0026quot;Start\u0026quot;) handlers := t.handlers log.Debug(\u0026quot;Processing handlers\u0026quot;) for _, handler := range handlers { t.scheduleRepeating(handler) } return nil }  The scheduleRepeating method is used to schedule a repeating job with a specified time interval. The variable called fn2 is executed when a timer fires and calls the flow it should trigger with the data specified in the map triggerData. The map contains a field called output which matches the name in the trigger.json file.\nfunc (t *MyTrigger) scheduleRepeating(endpoint *trigger.Handler) { log.Info(\u0026quot;Scheduling a repeating job\u0026quot;) fn2 := func() { // Create a map to hold the trigger data triggerData := map[string]interface{}{ \u0026quot;output\u0026quot;: \u0026quot;Hello World from the new Timer Trigger\u0026quot;, } _, err := endpoint.Handle(context.Background(), triggerData) if err != nil { log.Error(\u0026quot;Error running handler: \u0026quot;, err.Error()) } } t.scheduleJobEverySecond(endpoint, fn2) }  Finally, you\u0026rsquo;ll need to add a method called scheduleJobEverySecond to make sure the engine checks the timers on a regular basis and executes the function to trigger a flow.\nfunc (t *MyTrigger) scheduleJobEverySecond(tgrHandler *trigger.Handler, fn func()) { var interval int seconds, _ := strconv.Atoi(tgrHandler.GetStringSetting(\u0026quot;seconds\u0026quot;)) interval = interval + seconds log.Debug(\u0026quot;Repeating seconds: \u0026quot;, interval) // schedule repeating timerJob, err := scheduler.Every(interval).Seconds().Run(fn) if err != nil { log.Error(\u0026quot;Error scheduleRepeating (repeat seconds) flo err: \u0026quot;, err.Error()) } if timerJob == nil { log.Error(\u0026quot;timerJob is nil\u0026quot;) } t.timers = append(t.timers, timerJob) }  The completed file will look something like:\npackage MyTimerTrigger import ( \u0026quot;context\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/core/trigger\u0026quot; \u0026quot;github.com/TIBCOSoftware/flogo-lib/logger\u0026quot; \u0026quot;github.com/carlescere/scheduler\u0026quot; ) // Create a new logger var log = logger.GetLogger(\u0026quot;trigger-mytrigger\u0026quot;) // MyTriggerFactory My Trigger factory type MyTriggerFactory struct { metadata *trigger.Metadata } // NewFactory create a new Trigger factory func NewFactory(md *trigger.Metadata) trigger.Factory { return \u0026amp;MyTriggerFactory{metadata: md} } // New Creates a new trigger instance for a given id func (t *MyTriggerFactory) New(config *trigger.Config) trigger.Trigger { return \u0026amp;MyTrigger{metadata: t.metadata, config: config} } // MyTrigger is a stub for your Trigger implementation type MyTrigger struct { metadata *trigger.Metadata config *trigger.Config timers []*scheduler.Job handlers []*trigger.Handler } // Initialize implements trigger.Init.Initialize func (t *MyTrigger) Initialize(ctx trigger.InitContext) error { t.handlers = ctx.GetHandlers() return nil } // Metadata implements trigger.Trigger.Metadata func (t *MyTrigger) Metadata() *trigger.Metadata { return t.metadata } // Start implements trigger.Trigger.Start func (t *MyTrigger) Start() error { log.Debug(\u0026quot;Start\u0026quot;) handlers := t.handlers log.Debug(\u0026quot;Processing handlers\u0026quot;) for _, handler := range handlers { t.scheduleRepeating(handler) } return nil } // Stop implements trigger.Trigger.Start func (t *MyTrigger) Stop() error { // stop the trigger return nil } func (t *MyTrigger) scheduleRepeating(endpoint *trigger.Handler) { log.Info(\u0026quot;Scheduling a repeating job\u0026quot;) fn2 := func() { // Create a map to hold the trigger data triggerData := map[string]interface{}{ \u0026quot;output\u0026quot;: \u0026quot;Hello World from the new Timer Trigger\u0026quot;, } _, err := endpoint.Handle(context.Background(), triggerData) if err != nil { log.Error(\u0026quot;Error running handler: \u0026quot;, err.Error()) } } t.scheduleJobEverySecond(endpoint, fn2) } func (t *MyTrigger) scheduleJobEverySecond(tgrHandler *trigger.Handler, fn func()) { var interval int seconds, _ := strconv.Atoi(tgrHandler.GetStringSetting(\u0026quot;seconds\u0026quot;)) interval = interval + seconds log.Debug(\u0026quot;Repeating seconds: \u0026quot;, interval) // schedule repeating timerJob, err := scheduler.Every(interval).Seconds().Run(fn) if err != nil { log.Error(\u0026quot;Error scheduleRepeating (repeat seconds) flo err: \u0026quot;, err.Error()) } if timerJob == nil { log.Error(\u0026quot;timerJob is nil\u0026quot;) } t.timers = append(t.timers, timerJob) }  To make sure that you can test and build the new trigger, you\u0026rsquo;ll need to go get (pun intended) a few packages\ngo get github.com/TIBCOSoftware/flogo-lib/core/trigger go get github.com/TIBCOSoftware/flogo-lib/logger go get github.com/carlescere/scheduler  Use your new trigger in a flow Now the only thing left to do is use the trigger inside a Flogo app! You have two options, install the new trigger using the Flogo CLI or via the Web UI. In any case you\u0026rsquo;ll first want to publish your trigger to a Git repo (the same one you\u0026rsquo;ve used in the ref field in the trigger.json). To add the new trigger to a Flogo engine and use it in a flow you can import it using the following flogo CLI command, from your flow app directory):\nflogo install github.com/yourusername/yourrepository  or import it using the \u0026ldquo;Install new trigger\u0026rdquo; option in the Flogo Web UI, where you\u0026rsquo;ll need to provide the URL https://github.com/yourusername/yourrepository.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/cloudfoundry/",
	"title": "Cloud Deployments: Cloud Foundry",
	"tags": [],
	"description": "",
	"content": " Cloud Foundry is an open-source platform as a service (PaaS) that provides you with a choice of clouds, developer frameworks, and application services.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nCloud Foundry If you want to run Flogo apps in a Cloud Foundry environment, you have two options:\n Using the binary buildpack Using docker containers  If you want to try out Pivotal Cloud Foundry, you might to check out PCF Dev and follow the first three steps to get your environment up and running.\n Using the binary buildpack With the Cloud Foundry Binary Buildpack you can run arbitrary binary web servers on Cloud Foundry without the need to have a specific build pack for that language. Since Flogo can compile down to a binary, this saves you from installing additional buildpacks. There are a few prerequisites you need to take into account though:\n You\u0026rsquo;ll need a binary that is able to run on the same OS as CF is deployed (most likely Linux, which you can do with env GOOS=linux flogo build) You\u0026rsquo;ll need to make sure you\u0026rsquo;re using port 8080 for your Receive HTTP Message trigger  Steps to deploy:\n Make sure the app is executable: chmod +x \u0026lt;appname\u0026gt; Push to PCF: cf push \u0026lt;name in pcf\u0026gt; -c './\u0026lt;appname\u0026gt;' -b binary_buildpack  For more detailed information and more flags you can set during deployments, check Binary Buildpack in the Cloud Foundry docs.\nUsing docker  By default, apps deployed with the cf push command run in standard Cloud Foundry Linux containers. With Docker support enabled, Cloud Foundry can also deploy and manage apps running in Docker containers.\n To enable docker support an administrator has to run:\ncf enable-feature-flag diego_docker  For example, the below command would push and run the Project Flogo Web UI on Cloud Foundry\ncf push my-app --docker-image flogo/flogo-docker  For more detailed information and more flags you can set during deployments, check Deploy an App with Docker in the Cloud Foundry docs.\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/docker/",
	"title": "Cloud Deployments: Docker",
	"tags": [],
	"description": "",
	"content": " Flogo apps are ultralight so building docker images is not only really easy, because it can embed all dependencies it can also run inside of super small docker containers.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nUsing flogo Out of the box, Flogo has the option to build a docker container from the app.\nflogo build -e -docker \u0026lt;trigger id\u0026gt;  The above command will build a Flogo app, with embedded configuration (-e), and create a docker image where it can expose the PORT based on which trigger ID you specify. If you don\u0026rsquo;t want to expose a port (for example, because you start with a timer) you can specify no-trigger as the trigger id.\nThe docker file it generates and uses to build the docker image is:\n# Dockerfile for {{.name}} # VERSION {{.version}} FROM alpine RUN apk update \u0026amp;\u0026amp; apk add ca-certificates ADD {{.name}}-linux-amd64 . EXPOSE {{.port}} CMD ./{{.name}}-linux-amd64`  note that {{.name}} and {{.port}} are substitution variables coming from the configuration of your app\n After building the image you can run the container using the docker run command\nDo-It-Yourself While practical, you don\u0026rsquo;t have to rely on flogo to generate the docker image for you. If you prefer to construct the Dockerfile yourself, that is perfectly okay too. The flogo cli simply wraps the command:\ndocker build . -t \u0026lt;app name\u0026gt;:\u0026lt;app version\u0026gt;  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/hyperledger/",
	"title": "HyperLedger Fabric",
	"tags": [],
	"description": "",
	"content": " Dovetail can run almost anywhere\u0026hellip;..\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you. The app you\u0026rsquo;ll build has a REST trigger that counts the number of times it is invoked and logs that to the console.\n{ \u0026quot;name\u0026quot;: \u0026quot;IoTApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 9233 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:counter_flow\u0026quot; } }, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/counter\u0026quot; } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:counter_flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;CounterFlow\u0026quot;, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;counter_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Increment Counter\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Global Counter Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/counter\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;counterName\u0026quot;: \u0026quot;number\u0026quot;, \u0026quot;increment\u0026quot;: true, \u0026quot;reset\u0026quot;: false } } }, { \u0026quot;id\u0026quot;: \u0026quot;log_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;flowInfo\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$activity[counter_2].value\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;counter_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;log_3\u0026quot; } ] } } ] }  Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started  To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:9233/counter. It will send an HTTP request to the app on port 9233 (which was configured in the flogo.json file) and it will log the number of invocations.\nStep 4: Getting it to your device Once you are ready to test your application on your device, check out these specialized labs that talk about building Flogo apps specifically for that device.\n Raspberry Pi Intel Edison BeagleBone  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/iou-smart-app/",
	"title": "IOU Smart Contract",
	"tags": [],
	"description": "",
	"content": " # A Simple IOU Smart Contract Tutorial\nIn this tutorial, we will walk you through the steps to model, implement and test smart contracts into blockchain platform of your choice. The example is a simple \u0026ldquo;I owe you\u0026rdquo; use case, the issuer of an IOU is obligated to pay the owner of the IOU amount issued, the ownership of the IOU can be transferred by current owner, and all transactions will be recorded on the ledger.\nBefore getting started, you should have your development environment setup.\n1. Model IOU Smart Contract 1.1 Introduction to smart contract modeling Project Dovetail‚Ñ¢ supports Hyperledger Composer modeling language to model smart contract assets and transactions, not all features are supported, see below for support and limitations * Features Supported - Resource definitions, including assets, concepts, enums, transactions, events and participants. - Relationships - Imports - Decorators, Project Dovetail‚Ñ¢ has a predefine set of decorators\n Features Not Supported Yet\n Field validators  Limited Support\n  In order to be blockchain agnostic, Project Dovetail‚Ñ¢ maps participants to network participant\u0026rsquo;s identity, e.g. MSP identifier for Hyperledger Fabric, and party\u0026rsquo;s legal name for R3 Corda, participants are not stored on the ledger. Project Dovetail‚Ñ¢ defines a Party participant in its system namespace, it should be used by all resource definitions where participants are required, and Party should be alreays be by reference since they are exsiting entities.\n1.2 IOU Smart Contract We will use Visio Studio Code to create IOU smart contract model. - create a workspace folder, e.g. tutorial - create subfolders under tutorial - artifacts - network - fabric - corda - copy template project to the workspace, and rename the project as iou - under folder iou/model, create a file iou.cto - copy following resource definitions into iou.cto file\n namespace com.example.iou import com.tibco.dovetail.system.* asset IOU identified by linearId extends LinearState { --\u0026gt; Party issuer --\u0026gt; Party owner o Amount amt } /* @InitiatedBy - arg0: comma delimited list of authorized participants in the format of $tx.path.to.participant, or * for any participant - arg1: optional, comma delimited list of required attributes that must exist in the initiator's certificate in the format of name=value. */ @InitiatedBy(\u0026quot;$tx.iou.issuer\u0026quot;) transaction IssueIOU { o IOU iou } @InitiatedBy(\u0026quot;$tx.iou.owner\u0026quot;) transaction TransferIOU { --\u0026gt; IOU iou //by reference because the asset is already on the ledger --\u0026gt; Party newOwner } /* @Query : mark transaction as query only */ @Query() transaction getIOU { o String linearId } @Query() transaction getIOUIssuedBy { o String issuerPartyId }   Run Composer command from toturial directory to package the iou project, it will create a iou.bna file \u0026gt; composer archive create -a iou.bna -t dir -n iou  2. Import IOU Smart Contract Model  Start up Project Dovetail‚Ñ¢ Studio, it will display web URL to use Go to a browser and open the Web Studio Go to Connections Tab \u0026gt; Add Connection \u0026gt; Select Composer Connector Give the connection a name, then \u0026ldquo;Browse\u0026rdquo; to find the iou.bna file, click \u0026ldquo;Save Model\u0026rdquo; button.  \n3. Implement IOU Smart Contract 3.1 IssueIOU Transaction  Go to Apps Tab \u0026gt; Create to create a new Application \u0026ldquo;IOU\u0026rdquo; Create a flow \u0026gt; flow name \u0026ldquo;IssueIOU\u0026rdquo; \u0026gt; Select \u0026ldquo;SmartContract TXN Trigger\u0026rdquo; \u0026gt; Select \u0026ldquo;IOU\u0026rdquo; from model dropdown \u0026gt; Select \u0026ldquo;com.example.iou.IssueIOU\u0026rdquo; from transaction dropdown \u0026gt; Click \u0026ldquo;Done\u0026rdquo; button We will add a logger activity, ledger activity and response activity. We will also validate input before writing to ledger.  \n3.2 TransferIOU Transaction  Create a new flow to implement TransferIOU transaction \n  3.3 getIOU Transaction  Create a new flow to implement getIOU transaction \n  3.4 getIOUIssuedBy Transaction  Create a new flow to implement getIOUIssuedBy transaction We use \u0026ldquo;Custom Query\u0026rdquo; activity to query the ledger. This activity is NOT blockchain agnostic  define a input parameter \u0026ldquo;issuerId\u0026rdquo; define blochchain specific query string, use _$paramName for input substitution, in this example, we use Hyperledger Fabric CouchDB query syntax   \n4. Export IOU Smart Contract Application  Go to IOU application Click on \u0026ldquo;Export app\u0026rdquo; button, save the file IOU.json to artifacts folder  5. Generate Blockchain Artifacts 5.1 Hyperledger Fabric Run following command from tutorial directory Hyperledger Fabric chaincode is written to tutorial/artifacts/hlf folder\nFor testing, transaction security support is not enabled.\n /path/to/dovetail-cli contract generate -b fabric -m artifacts/IOU.json -v 1.0.0 -t artifacts/\n 5.2 R3 Corda Run folloowing command from tutorial directory, R3 Corda contract is written to tutorial/artifacts/corda folder, put kotlin-IOU-1.0.0.jar on your classpath to develop CordApps.\n /path/to/dovetail-cli contract generate -b corda -m artifacts/IOU.json -v 1.0.0 -t artifacts/ \u0026ndash;namespace com.example.iou\n 6. Test IOU Smart Contract 6.1 Hyperledger Fabric  Copy sample Hyperledger Fabric Network to your network/fabric directory Follow instructions, assuing you are running commands from fabric directory.  6.2 R3 Corda  Copy sample R3 CordApp to network/corda directory Follow instructions  7. Import an existing application  You can import an application into Project Dovetail‚Ñ¢ Studio  Go to Project Dovetail‚Ñ¢ Studio Create a new Application \u0026ldquo;IOUImport\u0026rdquo;, click on \u0026ldquo;Import\u0026rdquo; button, use this IOU.json   \n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/network/corda/corda_network/",
	"title": "IOU Smart Contract for Corda",
	"tags": [],
	"description": "",
	"content": " Test IOU Smart Contract in R3 Cora Network We will use Corda Demo Bench, install it if you don\u0026rsquo;t have it installed already.\n1. Start up Corda Demo Bench  First add all jars from corda directory Start up 3 nodes: Notary, charlie, alice, and bob Make sure they are all running befor contine. Follow the video for step by step instructions.  \n2. Issue an IOU At charlie terminal, issue an IOU\n flow start com.example.iou.IOUIssueInitiatorFlow iouValue: $100, owner: \u0026ldquo;O=alice,L=New York,C=US\u0026rdquo;, externalId: charlie100\n Now run following command from charlie, alice and bob\u0026rsquo;s terminals, you should see the IOU is now on both charlie and alice\u0026rsquo;s ledgers, but not on bob\u0026rsquo;s\n run vaultQuery contractStateType: com.example.iou.IOU\n 3. Transfer the IOU At alice termial, transfer IOU to bob\n flow start com.example.iou.IOUTransferInitiatorFlow iouId: charlie100, newOwner: \u0026ldquo;C=FR,L=Paris,O=bob\u0026rdquo;\n Now run following command from charlie, alice and bob\u0026rsquo;s terminals, you should see the IOU is now on both charlie and bob\u0026rsquo;s ledgers, but no longer on charlie\u0026rsquo;s\n run vaultQuery contractStateType: com.example.iou.IOU\n "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/network/fabric/fabric_network/",
	"title": "IOU Smart Contract for HyperFabric Ledger",
	"tags": [],
	"description": "",
	"content": " Test IOU chaincode in Hyperledger Fabric Network We need four docker images in order for \u0026ldquo;dev mode\u0026rdquo; to run against the supplied docker compose script. If you installed the fabric-samples repo clone and followed the instructions to download-platform-specific-binaries, then you should have the necessary Docker images installed locally.\n1. open a terminal, and execute following command to start up the network  docker-compose -f docker-compose-simple.yaml up\n open a terminal window, run docker ps, make sure container cli, chaincode, peer, orderer and couchdb are running\n2. open another terminal, execute following commands to connect to chaincode container and compile/start chaincode  docker exec -it chaincode bash\ncd iou\ngo build\nCORE_PEER_ADDRESS=peer:7052 CORE_CHAINCODE_ID_NAME=iou:0 ./iou\n 3. open a third termial, execute following commands to install/instantiate chaincoce from cli  docker exec -it cli bash\npeer chaincode install -p chaincodedev/chaincode/iou -n iou -v 0\npeer chaincode instantiate -n iou -v 0 -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[]}\u0026rsquo; -C myc\n 4. from the third (cli) terminal,execute following commands to invoke IssueIOU and getIOU transactions  peer chaincode invoke -n iou -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[\u0026ldquo;com.example.iou.IssueIOU\u0026rdquo;,\u0026ldquo;{\\\u0026ldquo;issuer\\\u0026rdquo;:\\\u0026ldquo;charlie\\\u0026ldquo;,\\\u0026ldquo;owner\\\u0026rdquo;:\\\u0026ldquo;alice\\\u0026ldquo;,\\\u0026ldquo;amt\\\u0026rdquo;:{\\\u0026ldquo;quantity\\\u0026rdquo;:10000,\\\u0026ldquo;currency\\\u0026rdquo;:\\\u0026ldquo;USD\\\u0026ldquo;},\\\u0026ldquo;linearId\\\u0026rdquo;:\\\u0026ldquo;testiou\\\u0026ldquo;}\u0026rdquo;]}\u0026rsquo; -C myc\npeer chaincode query -n iou -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[\u0026ldquo;com.example.iou.getIOU\u0026rdquo;,\u0026ldquo;testiou\u0026rdquo;]}\u0026rsquo; -C myc\n You should see the IOU returned.\n5. from the cli terminal,execute following commands to invoke TransferIOU and getIOU transactions  peer chaincode invoke -n iou -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[\u0026ldquo;com.example.iou.TransferIOU\u0026rdquo;,\u0026ldquo;{\\\u0026ldquo;linearId\\\u0026rdquo;:\\\u0026ldquo;testiou\\\u0026ldquo;}\u0026rdquo;, \u0026ldquo;bob\u0026rdquo;]}\u0026rsquo; -C myc\npeer chaincode query -n iou -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[\u0026ldquo;com.example.iou.getIOU\u0026rdquo;,\u0026ldquo;testiou\u0026rdquo;]}\u0026rsquo; -C myc\n You should see the IOU now with new owner \u0026ldquo;bob\u0026rdquo; returned\n6. query iou let\u0026rsquo;s add another IOU issued by charlie\n peer chaincode invoke -n iou -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[\u0026ldquo;com.example.iou.IssueIOU\u0026rdquo;,\u0026ldquo;{\\\u0026ldquo;issuer\\\u0026rdquo;:\\\u0026ldquo;charlie\\\u0026ldquo;,\\\u0026ldquo;owner\\\u0026rdquo;:\\\u0026ldquo;john\\\u0026ldquo;,\\\u0026ldquo;amt\\\u0026rdquo;:{\\\u0026ldquo;quantity\\\u0026rdquo;:20000,\\\u0026ldquo;currency\\\u0026rdquo;:\\\u0026ldquo;USD\\\u0026ldquo;},\\\u0026ldquo;linearId\\\u0026rdquo;:\\\u0026ldquo;testioujohn\\\u0026ldquo;}\u0026rdquo;]}\u0026rsquo; -C myc\npeer chaincode query -n iou -c \u0026lsquo;{\u0026ldquo;Args\u0026rdquo;:[\u0026ldquo;com.example.iou.getIOUIssuedBy\u0026rdquo;, \u0026ldquo;charlie\u0026rdquo;]}\u0026rsquo; -C myc\n You should see two IOUs returned, both issued by charlie.\n7. shutdown network  docker-compose -f docker-compose-simple.yaml down\n "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/r3corda/",
	"title": "IoT Apps",
	"tags": [],
	"description": "",
	"content": " Flogo can run almost anywhere. From the largest clouds, to the smallest of devices and everything in between. Take this lab to get yourself familiar with how to develop apps for IoT devices using the Flogo CLI.\nWhat you\u0026rsquo;ll need Flogo CLI This demo makes use of the Flogo CLI. If you don\u0026rsquo;t have that one running yet, please check out Getting Started with the Flogo CLI\nNeed help If you have any questions, feel free to post an issue on GitHub and tag it as a question or chat with the team and community:\n The project-flogo/Lobby Start here for all things Flogo! The project-flogo/developers Developer/contributor focused conversations.  Step 1: flogo.json Flogo apps are constructed using a JSON file called flogo.json. You can create those files using the Flogo Web UI, or you can create them manually. Now let\u0026rsquo;s create the flogo.json file. To do that, execute touch flogo.json in a terminal (or open up a new file in your text editor), which will create a new empty file for you. The app you\u0026rsquo;ll build has a REST trigger that counts the number of times it is invoked and logs that to the console.\n{ \u0026quot;name\u0026quot;: \u0026quot;IoTApp\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;flogo:app\u0026quot;, \u0026quot;version\u0026quot;: \u0026quot;0.0.1\u0026quot;, \u0026quot;appModel\u0026quot;: \u0026quot;1.0.0\u0026quot;, \u0026quot;triggers\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;receive_http_message\u0026quot;, \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/trigger/rest\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Receive HTTP Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple REST Trigger\u0026quot;, \u0026quot;settings\u0026quot;: { \u0026quot;port\u0026quot;: 9233 }, \u0026quot;handlers\u0026quot;: [ { \u0026quot;action\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/action/flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;flowURI\u0026quot;: \u0026quot;res://flow:counter_flow\u0026quot; } }, \u0026quot;settings\u0026quot;: { \u0026quot;method\u0026quot;: \u0026quot;GET\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/counter\u0026quot; } } ] } ], \u0026quot;resources\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;flow:counter_flow\u0026quot;, \u0026quot;data\u0026quot;: { \u0026quot;name\u0026quot;: \u0026quot;CounterFlow\u0026quot;, \u0026quot;tasks\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;counter_2\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Increment Counter\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Global Counter Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/counter\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;counterName\u0026quot;: \u0026quot;number\u0026quot;, \u0026quot;increment\u0026quot;: true, \u0026quot;reset\u0026quot;: false } } }, { \u0026quot;id\u0026quot;: \u0026quot;log_3\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Log Message\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Simple Log Activity\u0026quot;, \u0026quot;activity\u0026quot;: { \u0026quot;ref\u0026quot;: \u0026quot;github.com/TIBCOSoftware/flogo-contrib/activity/log\u0026quot;, \u0026quot;input\u0026quot;: { \u0026quot;flowInfo\u0026quot;: \u0026quot;false\u0026quot;, \u0026quot;addToFlow\u0026quot;: \u0026quot;false\u0026quot; }, \u0026quot;mappings\u0026quot;: { \u0026quot;input\u0026quot;: [ { \u0026quot;type\u0026quot;: \u0026quot;assign\u0026quot;, \u0026quot;value\u0026quot;: \u0026quot;$activity[counter_2].value\u0026quot;, \u0026quot;mapTo\u0026quot;: \u0026quot;message\u0026quot; } ] } } } ], \u0026quot;links\u0026quot;: [ { \u0026quot;from\u0026quot;: \u0026quot;counter_2\u0026quot;, \u0026quot;to\u0026quot;: \u0026quot;log_3\u0026quot; } ] } } ] }  Step 2: Building an app To create the source code simply execute flogo create -f flogo.json myapp. This tells the Flogo CLI to take the flogo.json file and create the source for the app in a folder called myapp. It will also download a few Go packages that the app will need.\nThe next step is to build the executable and for that we need to be in the directory myapp (cd myapp). To build a flogo app from the source you can execute the command flogo build -e, which tells the flogo cli to build the app (and place it in a bin directory) and embed all configuration into a single executable\nStep 3: Running the app You have just built the Flogo app, so now you can test it. From the bin directory (cd bin) you can run ./myapp which will start the app. In the terminal you\u0026rsquo;ll see something like\n2018-05-12 04:34:56.434 INFO [engine] - Engine Starting... 2018-05-12 04:34:56.435 INFO [engine] - Starting Services... 2018-05-12 04:34:56.435 INFO [engine] - Started Services 2018-05-12 04:34:56.435 INFO [engine] - Starting Triggers... 2018-05-12 04:34:56.435 INFO [engine] - Trigger [ receive_http_message ]: Started 2018-05-12 04:34:56.435 INFO [engine] - Triggers Started 2018-05-12 04:34:56.435 INFO [engine] - Engine Started  To test it we\u0026rsquo;ll use the curl command line tool, which is installed on most Operating Systems. From a new terminal window execute the command curl http://localhost:9233/counter. It will send an HTTP request to the app on port 9233 (which was configured in the flogo.json file) and it will log the number of invocations.\nStep 4: Getting it to your device Once you are ready to test your application on your device, check out these specialized labs that talk about building Flogo apps specifically for that device.\n Raspberry Pi Intel Edison BeagleBone  "
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/kubernetes/",
	"title": "Kubernetes",
	"tags": [],
	"description": "",
	"content": " Kubernetes is probably the most wellknown container orchestration platform out there, with a ton of companies building and hosting their own specific version or making use of of one. In this demo you explore how to run Flogo apps on Kubernetes. The demo will walk you through deploying two apps:\n An invoice service which gets details on the invoice you specify in the URL A payment service which gets details on the expected payment date for the invoice (The invoice service will make use of the payment service to display all data)  What you\u0026rsquo;ll need The demo needs a working Kubernetes cluster. If you haven\u0026rsquo;t got one, setting one up using minikube is quite easy! You\u0026rsquo;ll also need to have the Flogo CLI installed. If that is not the case, you might want to install them first. Our Getting Started guide walks you through the installation of Go, the Flogo CLI and Go Dep.\nScripts A fully scripted version of this tutorial is available in the samples directory as well! There are two different scenarios to deploy, one makes use of apps built using the Flogo Web UI and the other makes use of apps with the same functionality but built using the Go API.\nThe apps built with the Flogo Web UI are:\n Invoice Service Payment Service  The apps built with the Go API are:\n Invoice Service - Go Payment Service - Go  The shell script will allow you to choose between them, in this walk through you\u0026rsquo;ll make use of the apps built with the Flogo Web UI. In the scenario you\u0026rsquo;ll find a bunch of code blocks from which you can copy the code directly to your terminal. Please note that these commands are for MacOS and Linux, but should work on most Windows based systems as well.\nGetting the artifacts The first step is to create a directory that will contain all the artifacts. For now we\u0026rsquo;ll call that one flogo-on-kubernetes\n# Set a root directory so that all commands start from the same directory ROOTDIR=`pwd` # Set a working directory for all the artifacts WORKDIR=flogo-on-kubernetes # Make sure the directory is cleanly created rm -rf $ROOTDIR/$WORKDIR mkdir -p $ROOTDIR/$WORKDIR  Getting the Flogo apps The demo will consist of two apps deployed to a Kubernetes cluster. We\u0026rsquo;ll use docker images that already exist, but we do want to provide you with all the code and artifacts to show the apps in the Flogo Web UI. Let\u0026rsquo;s start with downloading the apps\ncd $ROOTDIR/$WORKDIR curl -o invoiceservice.json https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/invoiceservice.json curl -o paymentservice.json https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/paymentservice.json  For each of the apps we\u0026rsquo;ll need to run a command to create the app structure and download any dependencies\nflogo create -f invoiceservice.json invoiceservice flogo create -f paymentservice.json paymentservice  Creating executables Now, let\u0026rsquo;s build the executables for the first app. We\u0026rsquo;ll build two executables. One that will be able to run natively on your machine and one that will be a Linux executable to run in a docker container. So for the first app those commands are\ncd $ROOTDIR/$WORKDIR/invoiceservice env GOOS=linux flogo build -e flogo build -e  For the second app they are\ncd $ROOTDIR/$WORKDIR/paymentservice env GOOS=linux flogo build -e flogo build -e  Dockerize all the things Now on to Docker! We\u0026rsquo;ll create docker images based on Alpine Linux. We\u0026rsquo;ll put a Dockerfile in the bin/linux_amd64 folder and run the command\n# Set your Docker Hub username DOCKERHUBUSER=my-name # Go to the right directory cd $ROOTDIR/$WORKDIR/invoiceservice/bin/linux_amd64 # Get a Dockerfile curl -o Dockerfile https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/Dockerfile # Run the docker build command docker build -t $DOCKERHUBUSER/invoiceservice .  And we\u0026rsquo;ll do the same for the second service as well.\n# Go to the right directory cd $ROOTDIR/$WORKDIR/paymentservice/bin/linux_amd64 # Get a Dockerfile curl -o Dockerfile https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/Dockerfile # Run the docker build command docker build -t $DOCKERHUBUSER/paymentservice .  Running your Docker images Right now you have two new docker images available in your registry, which you could use to test the whole scenario as well. If you want to do that run the below commands in separate terminal windows\ndocker run --rm -it -p 9998:8080 $DOCKERHUBUSER/paymentservice docker run --rm -it -p 9999:8080 -e PAYMENTSERVICE=http://\u0026lt;YOUR IP\u0026gt;:9998/api/expected-date/:id $DOCKERHUBUSER/invoiceservice\u0026quot;  Now you can test the flow by running\n# For the payment service curl --request GET --url http://localhost:9998/api/expected-date/1234 # For the invoice service curl --request GET --url http://localhost:9999/api/invoices/1234  For more information and sample messages check out the prebuilt docker images for these services on Docker Hub\n invoiceservice paymentservice  Speaking of Docker Hub\u0026hellip; you can push your docker containers to Docker Hub (assuming you have an account for it) by running\ndocker push $DOCKERHUBUSER/paymentservice:latest docker push $DOCKERHUBUSER/invoiceservice:latest  On to Kubernetes The last step is to deploy to Kubernetes. To do that we need to download two additional files.\ncd $ROOTDIR/$WORKDIR curl -o invoice-svc.yml https://raw.githubusercontent.com/retgits/flogo-components/master/apps/invoiceservice/invoice-svc.yml curl -o payment-svc.yml https://raw.githubusercontent.com/retgits/flogo-components/master/apps/paymentservice/payment-svc.yml  The payment-svc.yml file will create a deployment and a service resource in your Kubernetes cluster. For that we\u0026rsquo;ll use an existing docker image called retgits/paymentservice, which is the same as the one you just built. If you want you can update the yaml file before running the below command.\nkubectl apply -f payment-svc.yml  You now have a docker container that is accessible as a service on Kubernetes. The payment service is accessible on port 80 of the cluster IP address that was assigned to it. If you want to try it out look for the CLUSTER-IP of the payment-svc in the output from kubectl get services\nkubectl run curl --image=radial/busyboxplus:curl -i --tty  This will start a new buxybox terminal in your cluster. From there you can run\ncurl \u0026lt;CLUSTERIP\u0026gt;/api/expected-date/3456  which should return something like \u0026quot;{\u0026quot;expectedDate\u0026quot;:\u0026quot;2018-02-26\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;3456\u0026quot;}\nThe second service we\u0026rsquo;ll make available using the type: LoadBalancer which means that you can access it from outside your Kubernetes cluster. For this we\u0026rsquo;ll use the existing container retgits/invoiceservice. If you open the invoice.yml file you\u0026rsquo;ll see that there is an environment variable called PAYMENTSERVICE (line 24) which points to the DNS entry for the payment service. This way we can makes updates and potentially move the payment service around without having to update this service.\nkubectl apply -f invoice-svc.yml  Done All done! You now have two Flogo apps running on a Kubernetes cluster which you invoke by sending a curl message to the Kubernetes IP address or localhost if you\u0026rsquo;re running Docker for Mac. You can execute a command like:\ncurl localhost:80/api/invoices/1234  which will return something like \u0026quot;{\u0026quot;amount\u0026quot;:1162,\u0026quot;balance\u0026quot;:718,\u0026quot;currency\u0026quot;:\u0026quot;USD\u0026quot;,\u0026quot;expectedPaymentDate\u0026quot;:\u0026quot;2018-03-02\u0026quot;,\u0026quot;id\u0026quot;:\u0026quot;1234\u0026quot;,\u0026quot;ref\u0026quot;:\u0026quot;INV-1234\u0026quot;}\u0026quot;\nHappy Kube-ing!!\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/labs/helloworld/",
	"title": "My First App: Hello World",
	"tags": [],
	"description": "",
	"content": " Like with every programming language, a \u0026ldquo;Hello World\u0026rdquo; project gets you started with some basic fundamentals and Project Flogo really isn\u0026rsquo;t that different. This lab will get you started with the Flogo Web UI and building a simple flow.\nWhat you\u0026rsquo;ll need The Flogo Web UI This demo makes use of the Flogo Web UI. To make it easy to get started the Flogo Web UI is packaged up as a docker image which you can get from [docker hub](docker hub. To install Docker for your operating system click here for macOS and here for Windows. The Flogo Web UI contains everything you\u0026rsquo;ll need to build your Flogo apps, without ever writing code.\nIf you\u0026rsquo;re planning to run on a Windows machine older than Windows 10, you\u0026rsquo;ll need to install Docker Toolbox\n Step 1: Starting the Flogo Web UI To get started with the latest version of the Flogo Web UI paste this command in a terminal window:\ndocker run -it -p 3303:3303 flogo/flogo-docker:latest eula-accept  The parameters after the docker run command are:\n -it: This parameter keeps a pseudo-tty terminal open and keeps the terminal running in interactive mode. The Flogo Web Ui will print logs to this terminal window -p 3303:3303: This parameter tells Docker to bind your computer\u0026rsquo;s port 3303 to the container\u0026rsquo;s port 3303 flogo/flogo-docker:latest: This parameter tells the Docker daemon which container you want to run. In this case it will try to get the latest version of flogo/flogo-docker eula-accept: This parameter says you\u0026rsquo;ve accepted the EULA agreement on our website  After it is done starting the container, you\u0026rsquo;ll see something like the image below in your terminal.\nTo see the Flogo Web UI, open your favorite web browser, and navigate to http://localhost:3303. You\u0026rsquo;ll see our mascot Flynn there to greet you!\nStep 2: Create the app In Flogo terminology, an app is comprised of one or more triggers and flows (actions). The app itself is really just an organizational mechanism that can be leveraged when developing microservices \u0026amp; functions. An app contains a set of configurations, as well as triggers and a collection of flows.\nTo create a new app, open the Flogo Web UI and from there, click \u0026ldquo;New\u0026rdquo; to create a new microservice and give your new app a name. Click \u0026ldquo;Create a Flow\u0026rdquo; to create a new flow and give it any name that you want. Now click on the flow you just created and to open the canvas where you can design your flow.\nStep 3: Add a flow In Flogo, a flow is an implementation of an action and is the primary tool to implement business logic. A flow can consist of a number of different constructs:\n Activties: One or more activities that implement specific logic (for example write to a database, invoke a REST endpoint, etc) Links: Each activity is connected via a link (Links can contain conditional logic to alter the path of a flow)  Flows, as previously stated in the triggers section, can exist without a trigger. Thus, flows operate very similar to functions, that is, a single flow can define its own input \u0026amp; output parameters. Thus, enabling a flow to be reused regardless of the trigger entrypoint To create a new flow you can click either the + New Flow button at the top or the Create a flow button in the middle of the screen.\nNo matter which you pick, you\u0026rsquo;ll be presented with a dialog to give your new flow a name and an optional description. Click Create to create the new flow and click on the newly created flow to open the editor.\nStep 4: Add a trigger Flogo is an event-driven framework. A trigger is the entrypoint for events to, as the name implies, trigger the functionality of your app. A trigger can be a subscriber on an MQTT topic, Kafka topic, HTTP REST interface or a specific IoT sensor. The trigger is responsible for accepting the incoming event and invoking one or more defined actions (flows).\nTo add a trigger, click on the \u0026ldquo;+\u0026rdquo; icon on the left hand side of the screen and select the Receive HTTP Message trigger.\nThe thing you want to log comes from the HTTP request. To get that parameter into the flow, you\u0026rsquo;ll need to create an Input parameter which you can do by clicking on the grey \u0026ldquo;Input Output\u0026rdquo; bar on your screen. For example, you can call the parameter \u0026ldquo;name\u0026rdquo;, keep the type as \u0026ldquo;string\u0026rdquo; and click save.\nThe response to the HTTP request will be a message and the HTTP status code, and to be able to send data back you\u0026rsquo;ll need to have Output parameters. From the screen where you are now, select Output and configure two parameters:\n Parameter name: code Type: integer  Now click on the + sign to add a new parameter\n Parameter name: message Type: any  Now it is time to configure the trigger to listen to HTTP messages. To start, click on the trigger and a new dialog will open with a bunch of options. In this dialog you\u0026rsquo;ll have to provide:\n Port: The port on which your app will listen (set this to 9233) Method: The HTTP method that will trigger this flow (set this to GET) Path: The path that will route the messages to this flow (set this to /test/:name, the :name means that you can use that as a path parameter in your mappings).  The URL on which our microservice will listen will be http://localhost:9233/test/:name (the :name is a parameter that you can replace with anything during runtime). If you made changes to any of the variables above, please make sure to change those in the rest of these examples.\n Step 5: Adding activities An activity is the unit of work that can be leveraged within a Flow. An activity can be any number of things and can be compared to a simple function in Go or any other procedural language, that is, an activity accepts input params and will return one or more objects on return, both input \u0026amp; output params are defined by the activity metadata. You‚Äôll have to add some acvitivities to the flow for it to do something. To add an activity click on the large + sign\nA list with all the activities the Flogo Web UI knows about will appear. From the list you can pick the \u0026ldquo;Log Message\u0026rdquo; activity (or use the searchbar to find it) and click it to make sure it is added to the flow. As you hover over the newly added activity, a cog will appear and as you hover over that thing, a menu will appear to configure your activity. In this window you can configure the inputs of the \u0026ldquo;Log Message\u0026rdquo; activity. Click on \u0026ldquo;a.. message\u0026rdquo; and type (or copy/paste) string.concat(\u0026quot;Hello \u0026quot;, $flow.name) in the box (on the right hand side of the screen).\nStep 6: Return data To complete the app, add a Return activity. To add an activity click on the large + sign.\nHover over the newly added activity to see the cog and select configure to bring up the modal to configure the activity. The return activity is always the last activity in a branch and sets the values that are returned to the trigger. Click on \u0026ldquo;123 code\u0026rdquo; and type 200 in the input field to set the HTTP Response code to 200. Now click on \u0026ldquo;a.. message\u0026rdquo; and type string.concat(\u0026quot;Hello \u0026quot;, $flow.name) in the input field. Finally click \u0026ldquo;Save\u0026rdquo; to complete the mapping.\nStep 7: Build Those were all the steps needed to design the flow, now let\u0026rsquo;s build an executable from it. On the main screen of your flow click on the \u0026lt; button on the top-left hand side of the screen. Click on build and select your operating system of choice! Flogo will compile a statically linked binary, meaning that there are no other dependencies that the executable you\u0026rsquo;re getting from the Flogo Web UI. No libraries to install, no frameworks to maintain or upgrade, just that one single binary that takes care of your flows.\nProject Flogo can build binaries for most platforms that exist. If you choose to build one for a unix based system (e.g. Linux or macOS) be sure to add the executable property to it (chmod +x \u0026lt;executable\u0026gt;).\n Step 8: Run your app To run the app double-click it (on Windows), or open a terminal and execute the downloaded binary. As you\u0026rsquo;ll do that, you\u0026rsquo;ll not only see the output of the log step, but you\u0026rsquo;ll see the same in your browser window as well. The URL on which our microservice will listen should be http://localhost:9233/test/:name (or might be different if you made changes in the previous steps). If you\u0026rsquo;re running it on your machine you can open a browser window and go to http://localhost:9233/test/flogo to see what the output was (spoiler alert: you\u0026rsquo;ll see \u0026quot;Hello flogo\u0026quot; in your web browser). To stop your app simply close the terminal window in which you started the app or press ctrl + c\n"
},
{
	"uri": "https://tibcosoftware.github.io/dovetail/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]